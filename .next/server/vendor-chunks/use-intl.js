"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/use-intl";
exports.ids = ["vendor-chunks/use-intl"];
exports.modules = {

/***/ "(ssr)/./node_modules/use-intl/dist/_IntlProvider.js":
/*!*****************************************************!*\
  !*** ./node_modules/use-intl/dist/_IntlProvider.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./development/_IntlProvider.js */ \"(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9fSW50bFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDZJQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VuZ2xpc2gtY291cnNlcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L19JbnRsUHJvdmlkZXIuanM/YTg2YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wcm9kdWN0aW9uL19JbnRsUHJvdmlkZXIuanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZXZlbG9wbWVudC9fSW50bFByb3ZpZGVyLmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/_IntlProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/_useLocale.js":
/*!**************************************************!*\
  !*** ./node_modules/use-intl/dist/_useLocale.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./development/_useLocale.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9fdXNlTG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLHVJQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL2VuZ2xpc2gtY291cnNlcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L191c2VMb2NhbGUuanM/MTYxYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9wcm9kdWN0aW9uL191c2VMb2NhbGUuanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZXZlbG9wbWVudC9fdXNlTG9jYWxlLmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/_useLocale.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js":
/*!************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nconst IntlContext = /*#__PURE__*/ React.createContext(undefined);\nvar IntlContext$1 = IntlContext;\nexports.IntlContext = IntlContext$1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9JbnRsQ29udGV4dC1iNWNjNmJlOC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLFFBQVFDLG1CQUFPQSxDQUFDO0FBRXBCLE1BQU1DLGNBQWMsV0FBVyxHQUFFRixNQUFNRyxhQUFhLENBQUNDO0FBQ3JELElBQUlDLGdCQUFnQkg7QUFFcEJJLG1CQUFtQixHQUFHRCIsInNvdXJjZXMiOlsid2VicGFjazovL2VuZ2xpc2gtY291cnNlcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2RldmVsb3BtZW50L0ludGxDb250ZXh0LWI1Y2M2YmU4LmpzPzQ3MGUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG5jb25zdCBJbnRsQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG52YXIgSW50bENvbnRleHQkMSA9IEludGxDb250ZXh0O1xuXG5leHBvcnRzLkludGxDb250ZXh0ID0gSW50bENvbnRleHQkMTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInJlcXVpcmUiLCJJbnRsQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJJbnRsQ29udGV4dCQxIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js":
/*!*****************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/_IntlProvider.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nvar IntlContext = __webpack_require__(/*! ./IntlContext-b5cc6be8.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar React__default = /*#__PURE__*/ _interopDefault(React);\nfunction IntlProvider(_ref) {\n    let { children, defaultTranslationValues, formats, getMessageFallback, locale, messages, now, onError, timeZone } = _ref;\n    const [messageFormatCache] = React.useState(()=>new Map());\n    // Memoizing this value helps to avoid triggering a re-render of all\n    // context consumers in case the configuration didn't change. However,\n    // if some of the non-primitive values change, a re-render will still\n    // be triggered. Note that there's no need to put `memo` on `IntlProvider`\n    // itself, because the `children` typically change on every render.\n    // There's some burden on the consumer side if it's important to reduce\n    // re-renders, put that's how React works.\n    // See: https://blog.isquaredsoftware.com/2020/05/blogged-answers-a-mostly-complete-guide-to-react-rendering-behavior/#context-updates-and-render-optimizations\n    const value = React.useMemo(()=>({\n            ...initializeConfig.initializeConfig({\n                locale,\n                defaultTranslationValues,\n                formats,\n                getMessageFallback,\n                messages,\n                now,\n                onError,\n                timeZone\n            }),\n            messageFormatCache\n        }), [\n        defaultTranslationValues,\n        formats,\n        getMessageFallback,\n        locale,\n        messageFormatCache,\n        messages,\n        now,\n        onError,\n        timeZone\n    ]);\n    return /*#__PURE__*/ React__default.default.createElement(IntlContext.IntlContext.Provider, {\n        value: value\n    }, children);\n}\nexports.IntlProvider = IntlProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fSW50bFByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLG1CQUFtQkQsbUJBQU9BLENBQUM7QUFDL0IsSUFBSUUsY0FBY0YsbUJBQU9BLENBQUM7QUFFMUIsU0FBU0csZ0JBQWlCQyxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVFLFNBQVNGO0lBQUU7QUFBRztBQUU5RSxJQUFJRyxpQkFBaUIsV0FBVyxHQUFFSixnQkFBZ0JKO0FBRWxELFNBQVNTLGFBQWFDLElBQUk7SUFDeEIsSUFBSSxFQUNGQyxRQUFRLEVBQ1JDLHdCQUF3QixFQUN4QkMsT0FBTyxFQUNQQyxrQkFBa0IsRUFDbEJDLE1BQU0sRUFDTkMsUUFBUSxFQUNSQyxHQUFHLEVBQ0hDLE9BQU8sRUFDUEMsUUFBUSxFQUNULEdBQUdUO0lBQ0osTUFBTSxDQUFDVSxtQkFBbUIsR0FBR3BCLE1BQU1xQixRQUFRLENBQUMsSUFBTSxJQUFJQztJQUV0RCxvRUFBb0U7SUFDcEUsc0VBQXNFO0lBQ3RFLHFFQUFxRTtJQUNyRSwwRUFBMEU7SUFDMUUsbUVBQW1FO0lBQ25FLHVFQUF1RTtJQUN2RSwwQ0FBMEM7SUFDMUMsK0pBQStKO0lBQy9KLE1BQU12QixRQUFRQyxNQUFNdUIsT0FBTyxDQUFDLElBQU87WUFDakMsR0FBR3JCLGlCQUFpQkEsZ0JBQWdCLENBQUM7Z0JBQ25DYTtnQkFDQUg7Z0JBQ0FDO2dCQUNBQztnQkFDQUU7Z0JBQ0FDO2dCQUNBQztnQkFDQUM7WUFDRixFQUFFO1lBQ0ZDO1FBQ0YsSUFBSTtRQUFDUjtRQUEwQkM7UUFBU0M7UUFBb0JDO1FBQVFLO1FBQW9CSjtRQUFVQztRQUFLQztRQUFTQztLQUFTO0lBQ3pILE9BQU8sV0FBVyxHQUFFWCxlQUFlRCxPQUFPLENBQUNpQixhQUFhLENBQUNyQixZQUFZQSxXQUFXLENBQUNzQixRQUFRLEVBQUU7UUFDekYxQixPQUFPQTtJQUNULEdBQUdZO0FBQ0w7QUFFQWIsb0JBQW9CLEdBQUdXIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW5nbGlzaC1jb3Vyc2VzLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZGV2ZWxvcG1lbnQvX0ludGxQcm92aWRlci5qcz9hMzJmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpbml0aWFsaXplQ29uZmlnID0gcmVxdWlyZSgnLi9pbml0aWFsaXplQ29uZmlnLWM1MDNlMjE1LmpzJyk7XG52YXIgSW50bENvbnRleHQgPSByZXF1aXJlKCcuL0ludGxDb250ZXh0LWI1Y2M2YmU4LmpzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cblxudmFyIFJlYWN0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChSZWFjdCk7XG5cbmZ1bmN0aW9uIEludGxQcm92aWRlcihfcmVmKSB7XG4gIGxldCB7XG4gICAgY2hpbGRyZW4sXG4gICAgZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzLFxuICAgIGZvcm1hdHMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIGxvY2FsZSxcbiAgICBtZXNzYWdlcyxcbiAgICBub3csXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9ID0gX3JlZjtcbiAgY29uc3QgW21lc3NhZ2VGb3JtYXRDYWNoZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgTWFwKCkpO1xuXG4gIC8vIE1lbW9pemluZyB0aGlzIHZhbHVlIGhlbHBzIHRvIGF2b2lkIHRyaWdnZXJpbmcgYSByZS1yZW5kZXIgb2YgYWxsXG4gIC8vIGNvbnRleHQgY29uc3VtZXJzIGluIGNhc2UgdGhlIGNvbmZpZ3VyYXRpb24gZGlkbid0IGNoYW5nZS4gSG93ZXZlcixcbiAgLy8gaWYgc29tZSBvZiB0aGUgbm9uLXByaW1pdGl2ZSB2YWx1ZXMgY2hhbmdlLCBhIHJlLXJlbmRlciB3aWxsIHN0aWxsXG4gIC8vIGJlIHRyaWdnZXJlZC4gTm90ZSB0aGF0IHRoZXJlJ3Mgbm8gbmVlZCB0byBwdXQgYG1lbW9gIG9uIGBJbnRsUHJvdmlkZXJgXG4gIC8vIGl0c2VsZiwgYmVjYXVzZSB0aGUgYGNoaWxkcmVuYCB0eXBpY2FsbHkgY2hhbmdlIG9uIGV2ZXJ5IHJlbmRlci5cbiAgLy8gVGhlcmUncyBzb21lIGJ1cmRlbiBvbiB0aGUgY29uc3VtZXIgc2lkZSBpZiBpdCdzIGltcG9ydGFudCB0byByZWR1Y2VcbiAgLy8gcmUtcmVuZGVycywgcHV0IHRoYXQncyBob3cgUmVhY3Qgd29ya3MuXG4gIC8vIFNlZTogaHR0cHM6Ly9ibG9nLmlzcXVhcmVkc29mdHdhcmUuY29tLzIwMjAvMDUvYmxvZ2dlZC1hbnN3ZXJzLWEtbW9zdGx5LWNvbXBsZXRlLWd1aWRlLXRvLXJlYWN0LXJlbmRlcmluZy1iZWhhdmlvci8jY29udGV4dC11cGRhdGVzLWFuZC1yZW5kZXItb3B0aW1pemF0aW9uc1xuICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAuLi5pbml0aWFsaXplQ29uZmlnLmluaXRpYWxpemVDb25maWcoe1xuICAgICAgbG9jYWxlLFxuICAgICAgZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzLFxuICAgICAgZm9ybWF0cyxcbiAgICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICAgIG1lc3NhZ2VzLFxuICAgICAgbm93LFxuICAgICAgb25FcnJvcixcbiAgICAgIHRpbWVab25lXG4gICAgfSksXG4gICAgbWVzc2FnZUZvcm1hdENhY2hlXG4gIH0pLCBbZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzLCBmb3JtYXRzLCBnZXRNZXNzYWdlRmFsbGJhY2ssIGxvY2FsZSwgbWVzc2FnZUZvcm1hdENhY2hlLCBtZXNzYWdlcywgbm93LCBvbkVycm9yLCB0aW1lWm9uZV0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0X19kZWZhdWx0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChJbnRsQ29udGV4dC5JbnRsQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB2YWx1ZVxuICB9LCBjaGlsZHJlbik7XG59XG5cbmV4cG9ydHMuSW50bFByb3ZpZGVyID0gSW50bFByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiUmVhY3QiLCJyZXF1aXJlIiwiaW5pdGlhbGl6ZUNvbmZpZyIsIkludGxDb250ZXh0IiwiX2ludGVyb3BEZWZhdWx0IiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiUmVhY3RfX2RlZmF1bHQiLCJJbnRsUHJvdmlkZXIiLCJfcmVmIiwiY2hpbGRyZW4iLCJkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMiLCJmb3JtYXRzIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwibG9jYWxlIiwibWVzc2FnZXMiLCJub3ciLCJvbkVycm9yIiwidGltZVpvbmUiLCJtZXNzYWdlRm9ybWF0Q2FjaGUiLCJ1c2VTdGF0ZSIsIk1hcCIsInVzZU1lbW8iLCJjcmVhdGVFbGVtZW50IiwiUHJvdmlkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/_useLocale-321e619f.js":
/*!***********************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/_useLocale-321e619f.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar IntlContext = __webpack_require__(/*! ./IntlContext-b5cc6be8.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\");\nfunction useIntlContext() {\n    const context = React.useContext(IntlContext.IntlContext);\n    if (!context) {\n        throw new Error(\"No intl context found. Have you configured the provider?\");\n    }\n    return context;\n}\nfunction useLocale() {\n    return useIntlContext().locale;\n}\nexports.useIntlContext = useIntlContext;\nexports.useLocale = useLocale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fdXNlTG9jYWxlLTMyMWU2MTlmLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsY0FBY0QsbUJBQU9BLENBQUM7QUFFMUIsU0FBU0U7SUFDUCxNQUFNQyxVQUFVSixNQUFNSyxVQUFVLENBQUNILFlBQVlBLFdBQVc7SUFDeEQsSUFBSSxDQUFDRSxTQUFTO1FBQ1osTUFBTSxJQUFJRSxNQUFNO0lBQ2xCO0lBQ0EsT0FBT0Y7QUFDVDtBQUVBLFNBQVNHO0lBQ1AsT0FBT0osaUJBQWlCSyxNQUFNO0FBQ2hDO0FBRUFDLHNCQUFzQixHQUFHTjtBQUN6Qk0saUJBQWlCLEdBQUdGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZW5nbGlzaC1jb3Vyc2VzLy4vbm9kZV9tb2R1bGVzL3VzZS1pbnRsL2Rpc3QvZGV2ZWxvcG1lbnQvX3VzZUxvY2FsZS0zMjFlNjE5Zi5qcz81NjQ0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBJbnRsQ29udGV4dCA9IHJlcXVpcmUoJy4vSW50bENvbnRleHQtYjVjYzZiZTguanMnKTtcblxuZnVuY3Rpb24gdXNlSW50bENvbnRleHQoKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KEludGxDb250ZXh0LkludGxDb250ZXh0KTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnRsIGNvbnRleHQgZm91bmQuIEhhdmUgeW91IGNvbmZpZ3VyZWQgdGhlIHByb3ZpZGVyPycgKTtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gdXNlTG9jYWxlKCkge1xuICByZXR1cm4gdXNlSW50bENvbnRleHQoKS5sb2NhbGU7XG59XG5cbmV4cG9ydHMudXNlSW50bENvbnRleHQgPSB1c2VJbnRsQ29udGV4dDtcbmV4cG9ydHMudXNlTG9jYWxlID0gdXNlTG9jYWxlO1xuIl0sIm5hbWVzIjpbIlJlYWN0IiwicmVxdWlyZSIsIkludGxDb250ZXh0IiwidXNlSW50bENvbnRleHQiLCJjb250ZXh0IiwidXNlQ29udGV4dCIsIkVycm9yIiwidXNlTG9jYWxlIiwibG9jYWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/_useLocale-321e619f.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/_useLocale.js":
/*!**************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/_useLocale.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _useLocale = __webpack_require__(/*! ./_useLocale-321e619f.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale-321e619f.js\");\n__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n__webpack_require__(/*! ./IntlContext-b5cc6be8.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\");\nexports.useLocale = _useLocale.useLocale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9fdXNlTG9jYWxlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLGFBQWFDLG1CQUFPQSxDQUFDO0FBQ3pCQSxtQkFBT0EsQ0FBQztBQUNSQSxtQkFBT0EsQ0FBQztBQUlSSCxpQkFBaUIsR0FBR0UsV0FBV0UsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2VuZ2xpc2gtY291cnNlcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2RldmVsb3BtZW50L191c2VMb2NhbGUuanM/NTBmMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBfdXNlTG9jYWxlID0gcmVxdWlyZSgnLi9fdXNlTG9jYWxlLTMyMWU2MTlmLmpzJyk7XG5yZXF1aXJlKCdyZWFjdCcpO1xucmVxdWlyZSgnLi9JbnRsQ29udGV4dC1iNWNjNmJlOC5qcycpO1xuXG5cblxuZXhwb3J0cy51c2VMb2NhbGUgPSBfdXNlTG9jYWxlLnVzZUxvY2FsZTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl91c2VMb2NhbGUiLCJyZXF1aXJlIiwidXNlTG9jYWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/_useLocale.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/core.js":
/*!********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/core.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-81d7e598.js */ \"(ssr)/./node_modules/use-intl/dist/development/createFormatter-81d7e598.js\");\n__webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\n__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction createTranslatorImpl(_ref, namespacePrefix) {\n    let { getMessageFallback, messages, namespace, onError, ...rest } = _ref;\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the function invocation.\n    messages = messages[namespacePrefix];\n    namespace = createFormatter.resolveNamespace(namespace, namespacePrefix);\n    return createFormatter.createBaseTranslator({\n        ...rest,\n        onError,\n        getMessageFallback,\n        messages,\n        namespace\n    });\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function createTranslator(_ref) {\n    let { getMessageFallback = initializeConfig.defaultGetMessageFallback, messages, namespace, onError = initializeConfig.defaultOnError, ...rest } = _ref;\n    // We have to wrap the actual function so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    return createTranslatorImpl({\n        ...rest,\n        onError,\n        getMessageFallback,\n        // @ts-expect-error `messages` is allowed to be `undefined` here and will be handled internally\n        messages: {\n            \"!\": messages\n        },\n        namespace: namespace ? \"!.\".concat(namespace) : \"!\"\n    }, \"!\");\n}\nexports.IntlError = initializeConfig.IntlError;\nexports.IntlErrorCode = initializeConfig.IntlErrorCode;\nexports.initializeConfig = initializeConfig.initializeConfig;\nexports.createFormatter = createFormatter.createFormatter;\nexports.createTranslator = createTranslator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUM7QUFDL0IsSUFBSUMsa0JBQWtCRCxtQkFBT0EsQ0FBQztBQUM5QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixTQUFTRSxxQkFBcUJDLElBQUksRUFBRUMsZUFBZTtJQUNqRCxJQUFJLEVBQ0ZDLGtCQUFrQixFQUNsQkMsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLE9BQU8sRUFDUCxHQUFHQyxNQUNKLEdBQUdOO0lBQ0osb0RBQW9EO0lBQ3BELDhDQUE4QztJQUM5Q0csV0FBV0EsUUFBUSxDQUFDRixnQkFBZ0I7SUFDcENHLFlBQVlOLGdCQUFnQlMsZ0JBQWdCLENBQUNILFdBQVdIO0lBQ3hELE9BQU9ILGdCQUFnQlUsb0JBQW9CLENBQUM7UUFDMUMsR0FBR0YsSUFBSTtRQUNQRDtRQUNBSDtRQUNBQztRQUNBQztJQUNGO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0ssaUJBQWlCVCxJQUFJO0lBQzVCLElBQUksRUFDRkUscUJBQXFCTixpQkFBaUJjLHlCQUF5QixFQUMvRFAsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFVBQVVULGlCQUFpQmUsY0FBYyxFQUN6QyxHQUFHTCxNQUNKLEdBQUdOO0lBQ0osNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSxpQ0FBaUM7SUFDakMsT0FBT0QscUJBQXFCO1FBQzFCLEdBQUdPLElBQUk7UUFDUEQ7UUFDQUg7UUFDQSwrRkFBK0Y7UUFDL0ZDLFVBQVU7WUFDUixLQUFLQTtRQUNQO1FBQ0FDLFdBQVdBLFlBQVksS0FBS1EsTUFBTSxDQUFDUixhQUFhO0lBQ2xELEdBQUc7QUFDTDtBQUVBVixpQkFBaUIsR0FBR0UsaUJBQWlCaUIsU0FBUztBQUM5Q25CLHFCQUFxQixHQUFHRSxpQkFBaUJrQixhQUFhO0FBQ3REcEIsd0JBQXdCLEdBQUdFLGlCQUFpQkEsZ0JBQWdCO0FBQzVERix1QkFBdUIsR0FBR0ksZ0JBQWdCQSxlQUFlO0FBQ3pESix3QkFBd0IsR0FBR2UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmdsaXNoLWNvdXJzZXMvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jb3JlLmpzP2RiODYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgaW5pdGlhbGl6ZUNvbmZpZyA9IHJlcXVpcmUoJy4vaW5pdGlhbGl6ZUNvbmZpZy1jNTAzZTIxNS5qcycpO1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vY3JlYXRlRm9ybWF0dGVyLTgxZDdlNTk4LmpzJyk7XG5yZXF1aXJlKCdpbnRsLW1lc3NhZ2Vmb3JtYXQnKTtcbnJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zbGF0b3JJbXBsKF9yZWYsIG5hbWVzcGFjZVByZWZpeCkge1xuICBsZXQge1xuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlcyxcbiAgICBuYW1lc3BhY2UsXG4gICAgb25FcnJvcixcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICAvLyBUaGUgYG5hbWVzcGFjZVByZWZpeGAgaXMgcGFydCBvZiB0aGUgdHlwZSBzeXN0ZW0uXG4gIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgZnVuY3Rpb24gaW52b2NhdGlvbi5cbiAgbWVzc2FnZXMgPSBtZXNzYWdlc1tuYW1lc3BhY2VQcmVmaXhdO1xuICBuYW1lc3BhY2UgPSBjcmVhdGVGb3JtYXR0ZXIucmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCk7XG4gIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIuY3JlYXRlQmFzZVRyYW5zbGF0b3Ioe1xuICAgIC4uLnJlc3QsXG4gICAgb25FcnJvcixcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXMsXG4gICAgbmFtZXNwYWNlXG4gIH0pO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRvcihfcmVmKSB7XG4gIGxldCB7XG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrID0gaW5pdGlhbGl6ZUNvbmZpZy5kZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIG1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSxcbiAgICBvbkVycm9yID0gaW5pdGlhbGl6ZUNvbmZpZy5kZWZhdWx0T25FcnJvcixcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIGFjdHVhbCBmdW5jdGlvbiBzbyB0aGUgdHlwZSBpbmZlcmVuY2UgZm9yIHRoZSBvcHRpb25hbFxuICAvLyBuYW1lc3BhY2Ugd29ya3MgY29ycmVjdGx5LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICAvLyBUaGUgcHJlZml4IChcIiFcIikgaXMgYXJiaXRyYXJ5LlxuICByZXR1cm4gY3JlYXRlVHJhbnNsYXRvckltcGwoe1xuICAgIC4uLnJlc3QsXG4gICAgb25FcnJvcixcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgbWVzc2FnZXNgIGlzIGFsbG93ZWQgdG8gYmUgYHVuZGVmaW5lZGAgaGVyZSBhbmQgd2lsbCBiZSBoYW5kbGVkIGludGVybmFsbHlcbiAgICBtZXNzYWdlczoge1xuICAgICAgJyEnOiBtZXNzYWdlc1xuICAgIH0sXG4gICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UgPyBcIiEuXCIuY29uY2F0KG5hbWVzcGFjZSkgOiAnISdcbiAgfSwgJyEnKTtcbn1cblxuZXhwb3J0cy5JbnRsRXJyb3IgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcjtcbmV4cG9ydHMuSW50bEVycm9yQ29kZSA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZTtcbmV4cG9ydHMuaW5pdGlhbGl6ZUNvbmZpZyA9IGluaXRpYWxpemVDb25maWcuaW5pdGlhbGl6ZUNvbmZpZztcbmV4cG9ydHMuY3JlYXRlRm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyLmNyZWF0ZUZvcm1hdHRlcjtcbmV4cG9ydHMuY3JlYXRlVHJhbnNsYXRvciA9IGNyZWF0ZVRyYW5zbGF0b3I7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbml0aWFsaXplQ29uZmlnIiwicmVxdWlyZSIsImNyZWF0ZUZvcm1hdHRlciIsImNyZWF0ZVRyYW5zbGF0b3JJbXBsIiwiX3JlZiIsIm5hbWVzcGFjZVByZWZpeCIsImdldE1lc3NhZ2VGYWxsYmFjayIsIm1lc3NhZ2VzIiwibmFtZXNwYWNlIiwib25FcnJvciIsInJlc3QiLCJyZXNvbHZlTmFtZXNwYWNlIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3IiLCJjcmVhdGVUcmFuc2xhdG9yIiwiZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayIsImRlZmF1bHRPbkVycm9yIiwiY29uY2F0IiwiSW50bEVycm9yIiwiSW50bEVycm9yQ29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/createFormatter-81d7e598.js":
/*!****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/createFormatter-81d7e598.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar IntlMessageFormat = __webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar IntlMessageFormat__default = /*#__PURE__*/ _interopDefault(IntlMessageFormat);\n// eslint-disable-next-line import/no-named-as-default -- False positive\nfunction setTimeZoneInFormats(formats, timeZone) {\n    if (!formats) return formats;\n    // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n    // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n    return Object.keys(formats).reduce((acc, key)=>{\n        acc[key] = {\n            timeZone,\n            ...formats[key]\n        };\n        return acc;\n    }, {});\n}\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */ function convertFormatsToIntlMessageFormat(formats, timeZone) {\n    const formatsWithTimeZone = timeZone ? {\n        ...formats,\n        dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)\n    } : formats;\n    const mfDateDefaults = IntlMessageFormat__default.default.formats.date;\n    const defaultDateFormats = timeZone ? setTimeZoneInFormats(mfDateDefaults, timeZone) : mfDateDefaults;\n    const mfTimeDefaults = IntlMessageFormat__default.default.formats.time;\n    const defaultTimeFormats = timeZone ? setTimeZoneInFormats(mfTimeDefaults, timeZone) : mfTimeDefaults;\n    return {\n        ...formatsWithTimeZone,\n        date: {\n            ...defaultDateFormats,\n            ...formatsWithTimeZone === null || formatsWithTimeZone === void 0 ? void 0 : formatsWithTimeZone.dateTime\n        },\n        time: {\n            ...defaultTimeFormats,\n            ...formatsWithTimeZone === null || formatsWithTimeZone === void 0 ? void 0 : formatsWithTimeZone.dateTime\n        }\n    };\n}\n// eslint-disable-next-line import/no-named-as-default -- False positive\nfunction resolvePath(locale, messages, key, namespace) {\n    const fullKey = initializeConfig.joinPath(namespace, key);\n    if (!messages) {\n        throw new Error(\"No messages available at `\".concat(namespace, \"`.\"));\n    }\n    let message = messages;\n    key.split(\".\").forEach((part)=>{\n        const next = message[part];\n        if (part == null || next == null) {\n            throw new Error(\"Could not resolve `\".concat(fullKey, \"` in messages for locale `\").concat(locale, \"`.\"));\n        }\n        message = next;\n    });\n    return message;\n}\nfunction prepareTranslationValues(values) {\n    if (Object.keys(values).length === 0) return undefined;\n    // Workaround for https://github.com/formatjs/formatjs/issues/1467\n    const transformedValues = {};\n    Object.keys(values).forEach((key)=>{\n        let index = 0;\n        const value = values[key];\n        let transformed;\n        if (typeof value === \"function\") {\n            transformed = (chunks)=>{\n                const result = value(chunks);\n                return /*#__PURE__*/ React.isValidElement(result) ? /*#__PURE__*/ React.cloneElement(result, {\n                    key: key + index++\n                }) : result;\n            };\n        } else {\n            transformed = value;\n        }\n        transformedValues[key] = transformed;\n    });\n    return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace) {\n    let onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : initializeConfig.defaultOnError;\n    try {\n        if (!messages) {\n            throw new Error(\"No messages were configured on the provider.\");\n        }\n        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n        if (!retrievedMessages) {\n            throw new Error(\"No messages for namespace `\".concat(namespace, \"` found.\"));\n        }\n        return retrievedMessages;\n    } catch (error) {\n        const intlError = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        onError(intlError);\n        return intlError;\n    }\n}\nfunction getPlainMessage(candidate, values) {\n    if (values) return undefined;\n    const unescapedMessage = candidate.replace(/'([{}])/gi, \"$1\");\n    // Placeholders can be in the message if there are default values,\n    // or if the user has forgotten to provide values. In the latter\n    // case we need to compile the message to receive an error.\n    const hasPlaceholders = /<|{/.test(unescapedMessage);\n    if (!hasPlaceholders) {\n        return unescapedMessage;\n    }\n    return undefined;\n}\nfunction createBaseTranslator(config) {\n    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);\n    return createBaseTranslatorImpl({\n        ...config,\n        messagesOrError\n    });\n}\nfunction createBaseTranslatorImpl(_ref) {\n    let { defaultTranslationValues, formats: globalFormats, getMessageFallback = initializeConfig.defaultGetMessageFallback, locale, messageFormatCache, messagesOrError, namespace, onError, timeZone } = _ref;\n    function getFallbackFromErrorAndNotify(key, code, message) {\n        const error = new initializeConfig.IntlError(code, message);\n        onError(error);\n        return getMessageFallback({\n            error,\n            key,\n            namespace\n        });\n    }\n    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        if (messagesOrError instanceof initializeConfig.IntlError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        let message;\n        try {\n            message = resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n        const cacheKey = initializeConfig.joinPath(locale, namespace, key, String(message));\n        let messageFormat;\n        if (messageFormatCache !== null && messageFormatCache !== void 0 && messageFormatCache.has(cacheKey)) {\n            messageFormat = messageFormatCache.get(cacheKey);\n        } else {\n            if (typeof message === \"object\") {\n                let code, errorMessage;\n                if (Array.isArray(message)) {\n                    code = initializeConfig.IntlErrorCode.INVALID_MESSAGE;\n                    {\n                        errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages\");\n                    }\n                } else {\n                    code = initializeConfig.IntlErrorCode.INSUFFICIENT_PATH;\n                    {\n                        errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an object, but only strings are supported. Use a `.` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages\");\n                    }\n                }\n                return getFallbackFromErrorAndNotify(key, code, errorMessage);\n            }\n            // Hot path that avoids creating an `IntlMessageFormat` instance\n            const plainMessage = getPlainMessage(message, values);\n            if (plainMessage) return plainMessage;\n            try {\n                messageFormat = new IntlMessageFormat__default.default(message, locale, convertFormatsToIntlMessageFormat({\n                    ...globalFormats,\n                    ...formats\n                }, timeZone), {\n                    formatters: {\n                        getNumberFormat (locales, options) {\n                            return new Intl.NumberFormat(locales, options);\n                        },\n                        getDateTimeFormat (locales, options) {\n                            // Workaround for https://github.com/formatjs/formatjs/issues/4279\n                            return new Intl.DateTimeFormat(locales, {\n                                timeZone,\n                                ...options\n                            });\n                        },\n                        getPluralRules (locales, options) {\n                            return new Intl.PluralRules(locales, options);\n                        }\n                    }\n                });\n            } catch (error) {\n                const thrownError = error;\n                return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, thrownError.message + (\"originalMessage\" in thrownError ? \" (\".concat(thrownError.originalMessage, \")\") : \"\"));\n            }\n            messageFormatCache === null || messageFormatCache === void 0 || messageFormatCache.set(cacheKey, messageFormat);\n        }\n        try {\n            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format\n            // for rich text elements since a recent minor update. This\n            // needs to be evaluated in detail, possibly also in regards\n            // to be able to format to parts.\n            prepareTranslationValues({\n                ...defaultTranslationValues,\n                ...values\n            }));\n            if (formattedMessage == null) {\n                throw new Error(\"Unable to format `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\"));\n            }\n            // Limit the function signature to return strings or React elements\n            return /*#__PURE__*/ React.isValidElement(formattedMessage) || // Arrays of React elements\n            Array.isArray(formattedMessage) || typeof formattedMessage === \"string\" ? formattedMessage : String(formattedMessage);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message);\n        }\n    }\n    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        const result = translateBaseFn(key, values, formats);\n        if (typeof result !== \"string\") {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, \"The message `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\", \" didn't resolve to a string. If you want to format rich text, use `t.rich` instead.\"));\n        }\n        return result;\n    }\n    translateFn.rich = translateBaseFn;\n    // Augment `translateBaseFn` to return plain strings\n    translateFn.markup = (key, values, formats)=>{\n        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n        // of `RichTranslationValues` but TypeScript isn't smart enough here.\n        values, formats);\n        // When only string chunks are provided to the parser, only\n        // strings should be returned here. Note that we need a runtime\n        // check for this since rich text values could be accidentally\n        // inherited from `defaultTranslationValues`.\n        if (typeof result !== \"string\") {\n            const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n            onError(error);\n            return getMessageFallback({\n                error,\n                key,\n                namespace\n            });\n        }\n        return result;\n    };\n    translateFn.raw = (key)=>{\n        if (messagesOrError instanceof initializeConfig.IntlError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        try {\n            return resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n    };\n    return translateFn;\n}\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */ function resolveNamespace(namespace, namespacePrefix) {\n    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + \".\").length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n    second: SECOND,\n    seconds: SECOND,\n    minute: MINUTE,\n    minutes: MINUTE,\n    hour: HOUR,\n    hours: HOUR,\n    day: DAY,\n    days: DAY,\n    week: WEEK,\n    weeks: WEEK,\n    month: MONTH,\n    months: MONTH,\n    quarter: QUARTER,\n    quarters: QUARTER,\n    year: YEAR,\n    years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n    const absValue = Math.abs(seconds);\n    if (absValue < MINUTE) {\n        return \"second\";\n    } else if (absValue < HOUR) {\n        return \"minute\";\n    } else if (absValue < DAY) {\n        return \"hour\";\n    } else if (absValue < WEEK) {\n        return \"day\";\n    } else if (absValue < MONTH) {\n        return \"week\";\n    } else if (absValue < YEAR) {\n        return \"month\";\n    }\n    return \"year\";\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n    // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n    // will include fractions like '2.1 hours ago'.\n    return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(_ref) {\n    let { formats, locale, now: globalNow, onError = initializeConfig.defaultOnError, timeZone: globalTimeZone } = _ref;\n    function applyTimeZone(options) {\n        var _options;\n        if (!((_options = options) !== null && _options !== void 0 && _options.timeZone)) {\n            if (globalTimeZone) {\n                options = {\n                    ...options,\n                    timeZone: globalTimeZone\n                };\n            } else {\n                onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `timeZone` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#time-zone\"));\n            }\n        }\n        return options;\n    }\n    function resolveFormatOrOptions(typeFormats, formatOrOptions) {\n        let options;\n        if (typeof formatOrOptions === \"string\") {\n            const formatName = formatOrOptions;\n            options = typeFormats === null || typeFormats === void 0 ? void 0 : typeFormats[formatName];\n            if (!options) {\n                const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_FORMAT, \"Format `\".concat(formatName, \"` is not available. You can configure it on the provider or provide custom options.\"));\n                onError(error);\n                throw error;\n            }\n        } else {\n            options = formatOrOptions;\n        }\n        return options;\n    }\n    function getFormattedValue(formatOrOptions, typeFormats, formatter, getFallback) {\n        let options;\n        try {\n            options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n        } catch (error) {\n            return getFallback();\n        }\n        try {\n            return formatter(options);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return getFallback();\n        }\n    }\n    function dateTime(/** If a number is supplied, this is interpreted as a UTC timestamp. */ value, /** If a time zone is supplied, the `value` is converted to that time zone.\n   * Otherwise the user time zone will be used. */ formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return new Intl.DateTimeFormat(locale, options).format(value);\n        }, ()=>String(value));\n    }\n    function dateTimeRange(/** If a number is supplied, this is interpreted as a UTC timestamp. */ start, /** If a number is supplied, this is interpreted as a UTC timestamp. */ end, /** If a time zone is supplied, the values are converted to that time zone.\n   * Otherwise the user time zone will be used. */ formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return new Intl.DateTimeFormat(locale, options).formatRange(start, end);\n        }, ()=>[\n                dateTime(start),\n                dateTime(end)\n            ].join(\" – \"));\n    }\n    function number(value, formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.number, (options)=>new Intl.NumberFormat(locale, options).format(value), ()=>String(value));\n    }\n    function getGlobalNow() {\n        if (globalNow) {\n            return globalNow;\n        } else {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `now` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#now\"));\n            return new Date();\n        }\n    }\n    function extractNowDate(nowOrOptions) {\n        if (nowOrOptions instanceof Date || typeof nowOrOptions === \"number\") {\n            return new Date(nowOrOptions);\n        }\n        if ((nowOrOptions === null || nowOrOptions === void 0 ? void 0 : nowOrOptions.now) !== undefined) {\n            return new Date(nowOrOptions.now);\n        }\n        return getGlobalNow();\n    }\n    function relativeTime(/** The date time that needs to be formatted. */ date, /** The reference point in time to which `date` will be formatted in relation to.  */ nowOrOptions) {\n        try {\n            const dateDate = new Date(date);\n            const nowDate = extractNowDate(nowOrOptions);\n            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n            const unit = typeof nowOrOptions === \"number\" || nowOrOptions instanceof Date || (nowOrOptions === null || nowOrOptions === void 0 ? void 0 : nowOrOptions.unit) === undefined ? resolveRelativeTimeUnit(seconds) : nowOrOptions.unit;\n            const value = calculateRelativeTimeValue(seconds, unit);\n            return new Intl.RelativeTimeFormat(locale, {\n                // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n                // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n                // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n                // not desired, as the given dates might cross a threshold were the\n                // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n                // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n                // case. By using `always` we can ensure correct output. The only exception\n                // is the formatting of times <1 second as \"now\".\n                numeric: unit === \"second\" ? \"auto\" : \"always\"\n            }).format(value, unit);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return String(date);\n        }\n    }\n    function list(value, formatOrOptions) {\n        const serializedValue = [];\n        const richValues = new Map();\n        // `formatToParts` only accepts strings, therefore we have to temporarily\n        // replace React elements with a placeholder ID that can be used to retrieve\n        // the original value afterwards.\n        let index = 0;\n        for (const item of value){\n            let serializedItem;\n            if (typeof item === \"object\") {\n                serializedItem = String(index);\n                richValues.set(serializedItem, item);\n            } else {\n                serializedItem = String(item);\n            }\n            serializedValue.push(serializedItem);\n            index++;\n        }\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n        (options)=>{\n            const result = new Intl.ListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === \"literal\" ? part.value : richValues.get(part.value) || part.value);\n            if (richValues.size > 0) {\n                return result;\n            } else {\n                return result.join(\"\");\n            }\n        }, ()=>String(value));\n    }\n    return {\n        dateTime,\n        number,\n        relativeTime,\n        list,\n        dateTimeRange\n    };\n}\nexports.createBaseTranslator = createBaseTranslator;\nexports.createFormatter = createFormatter;\nexports.resolveNamespace = resolveNamespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jcmVhdGVGb3JtYXR0ZXItODFkN2U1OTguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBQ2hDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUM7QUFFL0IsU0FBU0csZ0JBQWlCQyxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVFLFNBQVNGO0lBQUU7QUFBRztBQUU5RSxJQUFJRyw2QkFBNkIsV0FBVyxHQUFFSixnQkFBZ0JKO0FBRTlELHdFQUF3RTtBQUN4RSxTQUFTUyxxQkFBcUJDLE9BQU8sRUFBRUMsUUFBUTtJQUM3QyxJQUFJLENBQUNELFNBQVMsT0FBT0E7SUFFckIsNEZBQTRGO0lBQzVGLHNIQUFzSDtJQUN0SCxPQUFPRSxPQUFPQyxJQUFJLENBQUNILFNBQVNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQztRQUN2Q0QsR0FBRyxDQUFDQyxJQUFJLEdBQUc7WUFDVEw7WUFDQSxHQUFHRCxPQUFPLENBQUNNLElBQUk7UUFDakI7UUFDQSxPQUFPRDtJQUNULEdBQUcsQ0FBQztBQUNOO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0Usa0NBQWtDUCxPQUFPLEVBQUVDLFFBQVE7SUFDMUQsTUFBTU8sc0JBQXNCUCxXQUFXO1FBQ3JDLEdBQUdELE9BQU87UUFDVlMsVUFBVVYscUJBQXFCQyxRQUFRUyxRQUFRLEVBQUVSO0lBQ25ELElBQUlEO0lBQ0osTUFBTVUsaUJBQWlCWiwyQkFBMkJELE9BQU8sQ0FBQ0csT0FBTyxDQUFDVyxJQUFJO0lBQ3RFLE1BQU1DLHFCQUFxQlgsV0FBV0YscUJBQXFCVyxnQkFBZ0JULFlBQVlTO0lBQ3ZGLE1BQU1HLGlCQUFpQmYsMkJBQTJCRCxPQUFPLENBQUNHLE9BQU8sQ0FBQ2MsSUFBSTtJQUN0RSxNQUFNQyxxQkFBcUJkLFdBQVdGLHFCQUFxQmMsZ0JBQWdCWixZQUFZWTtJQUN2RixPQUFPO1FBQ0wsR0FBR0wsbUJBQW1CO1FBQ3RCRyxNQUFNO1lBQ0osR0FBR0Msa0JBQWtCO1lBQ3JCLEdBQUlKLHdCQUF3QixRQUFRQSx3QkFBd0IsS0FBSyxJQUFJLEtBQUssSUFBSUEsb0JBQW9CQyxRQUFRO1FBQzVHO1FBQ0FLLE1BQU07WUFDSixHQUFHQyxrQkFBa0I7WUFDckIsR0FBSVAsd0JBQXdCLFFBQVFBLHdCQUF3QixLQUFLLElBQUksS0FBSyxJQUFJQSxvQkFBb0JDLFFBQVE7UUFDNUc7SUFDRjtBQUNGO0FBRUEsd0VBQXdFO0FBQ3hFLFNBQVNPLFlBQVlDLE1BQU0sRUFBRUMsUUFBUSxFQUFFWixHQUFHLEVBQUVhLFNBQVM7SUFDbkQsTUFBTUMsVUFBVTNCLGlCQUFpQjRCLFFBQVEsQ0FBQ0YsV0FBV2I7SUFDckQsSUFBSSxDQUFDWSxVQUFVO1FBQ2IsTUFBTSxJQUFJSSxNQUFNLDZCQUE2QkMsTUFBTSxDQUFDSixXQUFXO0lBQ2pFO0lBQ0EsSUFBSUssVUFBVU47SUFDZFosSUFBSW1CLEtBQUssQ0FBQyxLQUFLQyxPQUFPLENBQUNDLENBQUFBO1FBQ3JCLE1BQU1DLE9BQU9KLE9BQU8sQ0FBQ0csS0FBSztRQUMxQixJQUFJQSxRQUFRLFFBQVFDLFFBQVEsTUFBTTtZQUNoQyxNQUFNLElBQUlOLE1BQU0sc0JBQXNCQyxNQUFNLENBQUNILFNBQVMsOEJBQThCRyxNQUFNLENBQUNOLFFBQVE7UUFDckc7UUFDQU8sVUFBVUk7SUFDWjtJQUNBLE9BQU9KO0FBQ1Q7QUFDQSxTQUFTSyx5QkFBeUJDLE1BQU07SUFDdEMsSUFBSTVCLE9BQU9DLElBQUksQ0FBQzJCLFFBQVFDLE1BQU0sS0FBSyxHQUFHLE9BQU9DO0lBRTdDLGtFQUFrRTtJQUNsRSxNQUFNQyxvQkFBb0IsQ0FBQztJQUMzQi9CLE9BQU9DLElBQUksQ0FBQzJCLFFBQVFKLE9BQU8sQ0FBQ3BCLENBQUFBO1FBQzFCLElBQUk0QixRQUFRO1FBQ1osTUFBTUMsUUFBUUwsTUFBTSxDQUFDeEIsSUFBSTtRQUN6QixJQUFJOEI7UUFDSixJQUFJLE9BQU9ELFVBQVUsWUFBWTtZQUMvQkMsY0FBY0MsQ0FBQUE7Z0JBQ1osTUFBTUMsU0FBU0gsTUFBTUU7Z0JBQ3JCLE9BQU8sV0FBVyxHQUFFN0MsTUFBTStDLGNBQWMsQ0FBQ0QsVUFBVSxXQUFXLEdBQUU5QyxNQUFNZ0QsWUFBWSxDQUFDRixRQUFRO29CQUN6RmhDLEtBQUtBLE1BQU00QjtnQkFDYixLQUFLSTtZQUNQO1FBQ0YsT0FBTztZQUNMRixjQUFjRDtRQUNoQjtRQUNBRixpQkFBaUIsQ0FBQzNCLElBQUksR0FBRzhCO0lBQzNCO0lBQ0EsT0FBT0g7QUFDVDtBQUNBLFNBQVNRLG1CQUFtQnhCLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxTQUFTO0lBQ3JELElBQUl1QixVQUFVQyxVQUFVWixNQUFNLEdBQUcsS0FBS1ksU0FBUyxDQUFDLEVBQUUsS0FBS1gsWUFBWVcsU0FBUyxDQUFDLEVBQUUsR0FBR2xELGlCQUFpQm1ELGNBQWM7SUFDakgsSUFBSTtRQUNGLElBQUksQ0FBQzFCLFVBQVU7WUFDYixNQUFNLElBQUlJLE1BQU07UUFDbEI7UUFDQSxNQUFNdUIsb0JBQW9CMUIsWUFBWUgsWUFBWUMsUUFBUUMsVUFBVUMsYUFBYUQ7UUFDakYsSUFBSSxDQUFDMkIsbUJBQW1CO1lBQ3RCLE1BQU0sSUFBSXZCLE1BQU0sOEJBQThCQyxNQUFNLENBQUNKLFdBQVc7UUFDbEU7UUFDQSxPQUFPMEI7SUFDVCxFQUFFLE9BQU9DLE9BQU87UUFDZCxNQUFNQyxZQUFZLElBQUl0RCxpQkFBaUJ1RCxTQUFTLENBQUN2RCxpQkFBaUJ3RCxhQUFhLENBQUNDLGVBQWUsRUFBRUosTUFBTXRCLE9BQU87UUFDOUdrQixRQUFRSztRQUNSLE9BQU9BO0lBQ1Q7QUFDRjtBQUNBLFNBQVNJLGdCQUFnQkMsU0FBUyxFQUFFdEIsTUFBTTtJQUN4QyxJQUFJQSxRQUFRLE9BQU9FO0lBQ25CLE1BQU1xQixtQkFBbUJELFVBQVVFLE9BQU8sQ0FBQyxhQUFhO0lBRXhELGtFQUFrRTtJQUNsRSxnRUFBZ0U7SUFDaEUsMkRBQTJEO0lBQzNELE1BQU1DLGtCQUFrQixNQUFNQyxJQUFJLENBQUNIO0lBQ25DLElBQUksQ0FBQ0UsaUJBQWlCO1FBQ3BCLE9BQU9GO0lBQ1Q7SUFDQSxPQUFPckI7QUFDVDtBQUNBLFNBQVN5QixxQkFBcUJDLE1BQU07SUFDbEMsTUFBTUMsa0JBQWtCbEIsbUJBQW1CaUIsT0FBT3pDLE1BQU0sRUFBRXlDLE9BQU94QyxRQUFRLEVBQUV3QyxPQUFPdkMsU0FBUyxFQUFFdUMsT0FBT2hCLE9BQU87SUFDM0csT0FBT2tCLHlCQUF5QjtRQUM5QixHQUFHRixNQUFNO1FBQ1RDO0lBQ0Y7QUFDRjtBQUNBLFNBQVNDLHlCQUF5QkMsSUFBSTtJQUNwQyxJQUFJLEVBQ0ZDLHdCQUF3QixFQUN4QjlELFNBQVMrRCxhQUFhLEVBQ3RCQyxxQkFBcUJ2RSxpQkFBaUJ3RSx5QkFBeUIsRUFDL0RoRCxNQUFNLEVBQ05pRCxrQkFBa0IsRUFDbEJQLGVBQWUsRUFDZnhDLFNBQVMsRUFDVHVCLE9BQU8sRUFDUHpDLFFBQVEsRUFDVCxHQUFHNEQ7SUFDSixTQUFTTSw4QkFBOEI3RCxHQUFHLEVBQUU4RCxJQUFJLEVBQUU1QyxPQUFPO1FBQ3ZELE1BQU1zQixRQUFRLElBQUlyRCxpQkFBaUJ1RCxTQUFTLENBQUNvQixNQUFNNUM7UUFDbkRrQixRQUFRSTtRQUNSLE9BQU9rQixtQkFBbUI7WUFDeEJsQjtZQUNBeEM7WUFDQWE7UUFDRjtJQUNGO0lBQ0EsU0FBU2tELGdCQUFpQiw2RUFBNkUsR0FDdkcvRCxHQUFHLEVBQUUsZ0VBQWdFLEdBQ3JFd0IsTUFBTSxFQUFFLHlEQUF5RCxHQUNqRTlCLE9BQU87UUFDTCxJQUFJMkQsMkJBQTJCbEUsaUJBQWlCdUQsU0FBUyxFQUFFO1lBQ3pELGtEQUFrRDtZQUNsRCxPQUFPZ0IsbUJBQW1CO2dCQUN4QmxCLE9BQU9hO2dCQUNQckQ7Z0JBQ0FhO1lBQ0Y7UUFDRjtRQUNBLE1BQU1ELFdBQVd5QztRQUNqQixJQUFJbkM7UUFDSixJQUFJO1lBQ0ZBLFVBQVVSLFlBQVlDLFFBQVFDLFVBQVVaLEtBQUthO1FBQy9DLEVBQUUsT0FBTzJCLE9BQU87WUFDZCxPQUFPcUIsOEJBQThCN0QsS0FBS2IsaUJBQWlCd0QsYUFBYSxDQUFDQyxlQUFlLEVBQUVKLE1BQU10QixPQUFPO1FBQ3pHO1FBQ0EsTUFBTThDLFdBQVc3RSxpQkFBaUI0QixRQUFRLENBQUNKLFFBQVFFLFdBQVdiLEtBQUtpRSxPQUFPL0M7UUFDMUUsSUFBSWdEO1FBQ0osSUFBSU4sdUJBQXVCLFFBQVFBLHVCQUF1QixLQUFLLEtBQUtBLG1CQUFtQk8sR0FBRyxDQUFDSCxXQUFXO1lBQ3BHRSxnQkFBZ0JOLG1CQUFtQlEsR0FBRyxDQUFDSjtRQUN6QyxPQUFPO1lBQ0wsSUFBSSxPQUFPOUMsWUFBWSxVQUFVO2dCQUMvQixJQUFJNEMsTUFBTU87Z0JBQ1YsSUFBSUMsTUFBTUMsT0FBTyxDQUFDckQsVUFBVTtvQkFDMUI0QyxPQUFPM0UsaUJBQWlCd0QsYUFBYSxDQUFDNkIsZUFBZTtvQkFDckQ7d0JBQ0VILGVBQWUsZUFBZXBELE1BQU0sQ0FBQzlCLGlCQUFpQjRCLFFBQVEsQ0FBQ0YsV0FBV2IsTUFBTTtvQkFDbEY7Z0JBQ0YsT0FBTztvQkFDTDhELE9BQU8zRSxpQkFBaUJ3RCxhQUFhLENBQUM4QixpQkFBaUI7b0JBQ3ZEO3dCQUNFSixlQUFlLGVBQWVwRCxNQUFNLENBQUM5QixpQkFBaUI0QixRQUFRLENBQUNGLFdBQVdiLE1BQU07b0JBQ2xGO2dCQUNGO2dCQUNBLE9BQU82RCw4QkFBOEI3RCxLQUFLOEQsTUFBTU87WUFDbEQ7WUFFQSxnRUFBZ0U7WUFDaEUsTUFBTUssZUFBZTdCLGdCQUFnQjNCLFNBQVNNO1lBQzlDLElBQUlrRCxjQUFjLE9BQU9BO1lBQ3pCLElBQUk7Z0JBQ0ZSLGdCQUFnQixJQUFJMUUsMkJBQTJCRCxPQUFPLENBQUMyQixTQUFTUCxRQUFRVixrQ0FBa0M7b0JBQ3hHLEdBQUd3RCxhQUFhO29CQUNoQixHQUFHL0QsT0FBTztnQkFDWixHQUFHQyxXQUFXO29CQUNaZ0YsWUFBWTt3QkFDVkMsaUJBQWdCQyxPQUFPLEVBQUVDLE9BQU87NEJBQzlCLE9BQU8sSUFBSUMsS0FBS0MsWUFBWSxDQUFDSCxTQUFTQzt3QkFDeEM7d0JBQ0FHLG1CQUFrQkosT0FBTyxFQUFFQyxPQUFPOzRCQUNoQyxrRUFBa0U7NEJBQ2xFLE9BQU8sSUFBSUMsS0FBS0csY0FBYyxDQUFDTCxTQUFTO2dDQUN0Q2xGO2dDQUNBLEdBQUdtRixPQUFPOzRCQUNaO3dCQUNGO3dCQUNBSyxnQkFBZU4sT0FBTyxFQUFFQyxPQUFPOzRCQUM3QixPQUFPLElBQUlDLEtBQUtLLFdBQVcsQ0FBQ1AsU0FBU0M7d0JBQ3ZDO29CQUNGO2dCQUNGO1lBQ0YsRUFBRSxPQUFPdEMsT0FBTztnQkFDZCxNQUFNNkMsY0FBYzdDO2dCQUNwQixPQUFPcUIsOEJBQThCN0QsS0FBS2IsaUJBQWlCd0QsYUFBYSxDQUFDNkIsZUFBZSxFQUFFYSxZQUFZbkUsT0FBTyxHQUFJLHNCQUFxQm1FLGNBQWMsS0FBS3BFLE1BQU0sQ0FBQ29FLFlBQVlDLGVBQWUsRUFBRSxPQUFPLEVBQUM7WUFDdk07WUFDQTFCLHVCQUF1QixRQUFRQSx1QkFBdUIsS0FBSyxLQUFLQSxtQkFBbUIyQixHQUFHLENBQUN2QixVQUFVRTtRQUNuRztRQUNBLElBQUk7WUFDRixNQUFNc0IsbUJBQW1CdEIsY0FBY3VCLE1BQU0sQ0FDN0MsbUVBQW1FO1lBQ25FLDJEQUEyRDtZQUMzRCw0REFBNEQ7WUFDNUQsaUNBQWlDO1lBQ2pDbEUseUJBQXlCO2dCQUN2QixHQUFHaUMsd0JBQXdCO2dCQUMzQixHQUFHaEMsTUFBTTtZQUNYO1lBQ0EsSUFBSWdFLG9CQUFvQixNQUFNO2dCQUM1QixNQUFNLElBQUl4RSxNQUFNLHFCQUFxQkMsTUFBTSxDQUFDakIsS0FBSyxTQUFTaUIsTUFBTSxDQUFDSixZQUFZLGNBQWNJLE1BQU0sQ0FBQ0osV0FBVyxPQUFPO1lBQ3RIO1lBRUEsbUVBQW1FO1lBQ25FLE9BQU8sV0FBVyxHQUFFM0IsTUFBTStDLGNBQWMsQ0FBQ3VELHFCQUN6QywyQkFBMkI7WUFDM0JsQixNQUFNQyxPQUFPLENBQUNpQixxQkFBcUIsT0FBT0EscUJBQXFCLFdBQVdBLG1CQUFtQnZCLE9BQU91QjtRQUN0RyxFQUFFLE9BQU9oRCxPQUFPO1lBQ2QsT0FBT3FCLDhCQUE4QjdELEtBQUtiLGlCQUFpQndELGFBQWEsQ0FBQytDLGdCQUFnQixFQUFFbEQsTUFBTXRCLE9BQU87UUFDMUc7SUFDRjtJQUNBLFNBQVN5RSxZQUFhLDZFQUE2RSxHQUNuRzNGLEdBQUcsRUFBRSxnRUFBZ0UsR0FDckV3QixNQUFNLEVBQUUseURBQXlELEdBQ2pFOUIsT0FBTztRQUNMLE1BQU1zQyxTQUFTK0IsZ0JBQWdCL0QsS0FBS3dCLFFBQVE5QjtRQUM1QyxJQUFJLE9BQU9zQyxXQUFXLFVBQVU7WUFDOUIsT0FBTzZCLDhCQUE4QjdELEtBQUtiLGlCQUFpQndELGFBQWEsQ0FBQzZCLGVBQWUsRUFBRSxnQkFBZ0J2RCxNQUFNLENBQUNqQixLQUFLLFNBQVNpQixNQUFNLENBQUNKLFlBQVksY0FBY0ksTUFBTSxDQUFDSixXQUFXLE9BQU8sWUFBWTtRQUN2TTtRQUNBLE9BQU9tQjtJQUNUO0lBQ0EyRCxZQUFZQyxJQUFJLEdBQUc3QjtJQUVuQixvREFBb0Q7SUFDcEQ0QixZQUFZRSxNQUFNLEdBQUcsQ0FBQzdGLEtBQUt3QixRQUFROUI7UUFDakMsTUFBTXNDLFNBQVMrQixnQkFBZ0IvRCxLQUMvQiwwRUFBMEU7UUFDMUUscUVBQXFFO1FBQ3JFd0IsUUFBUTlCO1FBRVIsMkRBQTJEO1FBQzNELCtEQUErRDtRQUMvRCw4REFBOEQ7UUFDOUQsNkNBQTZDO1FBQzdDLElBQUksT0FBT3NDLFdBQVcsVUFBVTtZQUM5QixNQUFNUSxRQUFRLElBQUlyRCxpQkFBaUJ1RCxTQUFTLENBQUN2RCxpQkFBaUJ3RCxhQUFhLENBQUMrQyxnQkFBZ0IsRUFBRTtZQUM5RnRELFFBQVFJO1lBQ1IsT0FBT2tCLG1CQUFtQjtnQkFDeEJsQjtnQkFDQXhDO2dCQUNBYTtZQUNGO1FBQ0Y7UUFDQSxPQUFPbUI7SUFDVDtJQUNBMkQsWUFBWUcsR0FBRyxHQUFHOUYsQ0FBQUE7UUFDaEIsSUFBSXFELDJCQUEyQmxFLGlCQUFpQnVELFNBQVMsRUFBRTtZQUN6RCxrREFBa0Q7WUFDbEQsT0FBT2dCLG1CQUFtQjtnQkFDeEJsQixPQUFPYTtnQkFDUHJEO2dCQUNBYTtZQUNGO1FBQ0Y7UUFDQSxNQUFNRCxXQUFXeUM7UUFDakIsSUFBSTtZQUNGLE9BQU8zQyxZQUFZQyxRQUFRQyxVQUFVWixLQUFLYTtRQUM1QyxFQUFFLE9BQU8yQixPQUFPO1lBQ2QsT0FBT3FCLDhCQUE4QjdELEtBQUtiLGlCQUFpQndELGFBQWEsQ0FBQ0MsZUFBZSxFQUFFSixNQUFNdEIsT0FBTztRQUN6RztJQUNGO0lBQ0EsT0FBT3lFO0FBQ1Q7QUFFQTs7O0NBR0MsR0FDRCxTQUFTSSxpQkFBaUJsRixTQUFTLEVBQUVtRixlQUFlO0lBQ2xELE9BQU9uRixjQUFjbUYsa0JBQWtCdEUsWUFBWWIsVUFBVW9GLEtBQUssQ0FBQyxDQUFDRCxrQkFBa0IsR0FBRSxFQUFHdkUsTUFBTTtBQUNuRztBQUVBLE1BQU15RSxTQUFTO0FBQ2YsTUFBTUMsU0FBU0QsU0FBUztBQUN4QixNQUFNRSxPQUFPRCxTQUFTO0FBQ3RCLE1BQU1FLE1BQU1ELE9BQU87QUFDbkIsTUFBTUUsT0FBT0QsTUFBTTtBQUNuQixNQUFNRSxRQUFRRixNQUFPLE9BQU0sRUFBQyxHQUFJLGdCQUFnQjtBQUNoRCxNQUFNRyxVQUFVRCxRQUFRO0FBQ3hCLE1BQU1FLE9BQU9KLE1BQU07QUFDbkIsTUFBTUssZUFBZTtJQUNuQkMsUUFBUVQ7SUFDUlUsU0FBU1Y7SUFDVFcsUUFBUVY7SUFDUlcsU0FBU1g7SUFDVFksTUFBTVg7SUFDTlksT0FBT1o7SUFDUGEsS0FBS1o7SUFDTGEsTUFBTWI7SUFDTmMsTUFBTWI7SUFDTmMsT0FBT2Q7SUFDUGUsT0FBT2Q7SUFDUGUsUUFBUWY7SUFDUmdCLFNBQVNmO0lBQ1RnQixVQUFVaEI7SUFDVmlCLE1BQU1oQjtJQUNOaUIsT0FBT2pCO0FBQ1Q7QUFDQSxTQUFTa0Isd0JBQXdCZixPQUFPO0lBQ3RDLE1BQU1nQixXQUFXQyxLQUFLQyxHQUFHLENBQUNsQjtJQUMxQixJQUFJZ0IsV0FBV3pCLFFBQVE7UUFDckIsT0FBTztJQUNULE9BQU8sSUFBSXlCLFdBQVd4QixNQUFNO1FBQzFCLE9BQU87SUFDVCxPQUFPLElBQUl3QixXQUFXdkIsS0FBSztRQUN6QixPQUFPO0lBQ1QsT0FBTyxJQUFJdUIsV0FBV3RCLE1BQU07UUFDMUIsT0FBTztJQUNULE9BQU8sSUFBSXNCLFdBQVdyQixPQUFPO1FBQzNCLE9BQU87SUFDVCxPQUFPLElBQUlxQixXQUFXbkIsTUFBTTtRQUMxQixPQUFPO0lBQ1Q7SUFDQSxPQUFPO0FBQ1Q7QUFDQSxTQUFTc0IsMkJBQTJCbkIsT0FBTyxFQUFFb0IsSUFBSTtJQUMvQyxzRUFBc0U7SUFDdEUsK0NBQStDO0lBQy9DLE9BQU9ILEtBQUtJLEtBQUssQ0FBQ3JCLFVBQVVGLFlBQVksQ0FBQ3NCLEtBQUs7QUFDaEQ7QUFDQSxTQUFTRSxnQkFBZ0IzRSxJQUFJO0lBQzNCLElBQUksRUFDRjdELE9BQU8sRUFDUGlCLE1BQU0sRUFDTndILEtBQUtDLFNBQVMsRUFDZGhHLFVBQVVqRCxpQkFBaUJtRCxjQUFjLEVBQ3pDM0MsVUFBVTBJLGNBQWMsRUFDekIsR0FBRzlFO0lBQ0osU0FBUytFLGNBQWN4RCxPQUFPO1FBQzVCLElBQUl5RDtRQUNKLElBQUksQ0FBRSxFQUFDQSxXQUFXekQsT0FBTSxNQUFPLFFBQVF5RCxhQUFhLEtBQUssS0FBS0EsU0FBUzVJLFFBQVEsR0FBRztZQUNoRixJQUFJMEksZ0JBQWdCO2dCQUNsQnZELFVBQVU7b0JBQ1IsR0FBR0EsT0FBTztvQkFDVm5GLFVBQVUwSTtnQkFDWjtZQUNGLE9BQU87Z0JBQ0xqRyxRQUFRLElBQUlqRCxpQkFBaUJ1RCxTQUFTLENBQUN2RCxpQkFBaUJ3RCxhQUFhLENBQUM2RixvQkFBb0IsRUFBRTtZQUM5RjtRQUNGO1FBQ0EsT0FBTzFEO0lBQ1Q7SUFDQSxTQUFTMkQsdUJBQXVCQyxXQUFXLEVBQUVDLGVBQWU7UUFDMUQsSUFBSTdEO1FBQ0osSUFBSSxPQUFPNkQsb0JBQW9CLFVBQVU7WUFDdkMsTUFBTUMsYUFBYUQ7WUFDbkI3RCxVQUFVNEQsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLElBQUksS0FBSyxJQUFJQSxXQUFXLENBQUNFLFdBQVc7WUFDM0YsSUFBSSxDQUFDOUQsU0FBUztnQkFDWixNQUFNdEMsUUFBUSxJQUFJckQsaUJBQWlCdUQsU0FBUyxDQUFDdkQsaUJBQWlCd0QsYUFBYSxDQUFDa0csY0FBYyxFQUFFLFdBQVc1SCxNQUFNLENBQUMySCxZQUFZO2dCQUMxSHhHLFFBQVFJO2dCQUNSLE1BQU1BO1lBQ1I7UUFDRixPQUFPO1lBQ0xzQyxVQUFVNkQ7UUFDWjtRQUNBLE9BQU83RDtJQUNUO0lBQ0EsU0FBU2dFLGtCQUFrQkgsZUFBZSxFQUFFRCxXQUFXLEVBQUVLLFNBQVMsRUFBRUMsV0FBVztRQUM3RSxJQUFJbEU7UUFDSixJQUFJO1lBQ0ZBLFVBQVUyRCx1QkFBdUJDLGFBQWFDO1FBQ2hELEVBQUUsT0FBT25HLE9BQU87WUFDZCxPQUFPd0c7UUFDVDtRQUNBLElBQUk7WUFDRixPQUFPRCxVQUFVakU7UUFDbkIsRUFBRSxPQUFPdEMsT0FBTztZQUNkSixRQUFRLElBQUlqRCxpQkFBaUJ1RCxTQUFTLENBQUN2RCxpQkFBaUJ3RCxhQUFhLENBQUMrQyxnQkFBZ0IsRUFBRWxELE1BQU10QixPQUFPO1lBQ3JHLE9BQU84SDtRQUNUO0lBQ0Y7SUFDQSxTQUFTN0ksU0FBVSxxRUFBcUUsR0FDeEYwQixLQUFLLEVBQ0w7Z0RBQzhDLEdBQzlDOEcsZUFBZTtRQUNiLE9BQU9HLGtCQUFrQkgsaUJBQWlCakosWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFTLFFBQVEsRUFBRTJFLENBQUFBO1lBQzVHQSxVQUFVd0QsY0FBY3hEO1lBQ3hCLE9BQU8sSUFBSUMsS0FBS0csY0FBYyxDQUFDdkUsUUFBUW1FLFNBQVNXLE1BQU0sQ0FBQzVEO1FBQ3pELEdBQUcsSUFBTW9DLE9BQU9wQztJQUNsQjtJQUNBLFNBQVNvSCxjQUFlLHFFQUFxRSxHQUM3RkMsS0FBSyxFQUFFLHFFQUFxRSxHQUM1RUMsR0FBRyxFQUNIO2dEQUM4QyxHQUM5Q1IsZUFBZTtRQUNiLE9BQU9HLGtCQUFrQkgsaUJBQWlCakosWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFTLFFBQVEsRUFBRTJFLENBQUFBO1lBQzVHQSxVQUFVd0QsY0FBY3hEO1lBQ3hCLE9BQU8sSUFBSUMsS0FBS0csY0FBYyxDQUFDdkUsUUFBUW1FLFNBQVNzRSxXQUFXLENBQUNGLE9BQU9DO1FBQ3JFLEdBQUcsSUFBTTtnQkFBQ2hKLFNBQVMrSTtnQkFBUS9JLFNBQVNnSjthQUFLLENBQUNFLElBQUksQ0FBQztJQUNqRDtJQUNBLFNBQVNDLE9BQU96SCxLQUFLLEVBQUU4RyxlQUFlO1FBQ3BDLE9BQU9HLGtCQUFrQkgsaUJBQWlCakosWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVE0SixNQUFNLEVBQUV4RSxDQUFBQSxVQUFXLElBQUlDLEtBQUtDLFlBQVksQ0FBQ3JFLFFBQVFtRSxTQUFTVyxNQUFNLENBQUM1RCxRQUFRLElBQU1vQyxPQUFPcEM7SUFDNUw7SUFDQSxTQUFTMEg7UUFDUCxJQUFJbkIsV0FBVztZQUNiLE9BQU9BO1FBQ1QsT0FBTztZQUNMaEcsUUFBUSxJQUFJakQsaUJBQWlCdUQsU0FBUyxDQUFDdkQsaUJBQWlCd0QsYUFBYSxDQUFDNkYsb0JBQW9CLEVBQUU7WUFDNUYsT0FBTyxJQUFJZ0I7UUFDYjtJQUNGO0lBQ0EsU0FBU0MsZUFBZUMsWUFBWTtRQUNsQyxJQUFJQSx3QkFBd0JGLFFBQVEsT0FBT0UsaUJBQWlCLFVBQVU7WUFDcEUsT0FBTyxJQUFJRixLQUFLRTtRQUNsQjtRQUNBLElBQUksQ0FBQ0EsaUJBQWlCLFFBQVFBLGlCQUFpQixLQUFLLElBQUksS0FBSyxJQUFJQSxhQUFhdkIsR0FBRyxNQUFNekcsV0FBVztZQUNoRyxPQUFPLElBQUk4SCxLQUFLRSxhQUFhdkIsR0FBRztRQUNsQztRQUNBLE9BQU9vQjtJQUNUO0lBQ0EsU0FBU0ksYUFBYyw4Q0FBOEMsR0FDckV0SixJQUFJLEVBQUUsbUZBQW1GLEdBQ3pGcUosWUFBWTtRQUNWLElBQUk7WUFDRixNQUFNRSxXQUFXLElBQUlKLEtBQUtuSjtZQUMxQixNQUFNd0osVUFBVUosZUFBZUM7WUFDL0IsTUFBTTlDLFVBQVUsQ0FBQ2dELFNBQVNFLE9BQU8sS0FBS0QsUUFBUUMsT0FBTyxFQUFDLElBQUs7WUFDM0QsTUFBTTlCLE9BQU8sT0FBTzBCLGlCQUFpQixZQUFZQSx3QkFBd0JGLFFBQVEsQ0FBQ0UsaUJBQWlCLFFBQVFBLGlCQUFpQixLQUFLLElBQUksS0FBSyxJQUFJQSxhQUFhMUIsSUFBSSxNQUFNdEcsWUFBWWlHLHdCQUF3QmYsV0FBVzhDLGFBQWExQixJQUFJO1lBQ3JPLE1BQU1uRyxRQUFRa0csMkJBQTJCbkIsU0FBU29CO1lBQ2xELE9BQU8sSUFBSWpELEtBQUtnRixrQkFBa0IsQ0FBQ3BKLFFBQVE7Z0JBQ3pDLHVFQUF1RTtnQkFDdkUseUVBQXlFO2dCQUN6RSx3RUFBd0U7Z0JBQ3hFLG1FQUFtRTtnQkFDbkUsc0VBQXNFO2dCQUN0RSx1RUFBdUU7Z0JBQ3ZFLDJFQUEyRTtnQkFDM0UsaURBQWlEO2dCQUNqRHFKLFNBQVNoQyxTQUFTLFdBQVcsU0FBUztZQUN4QyxHQUFHdkMsTUFBTSxDQUFDNUQsT0FBT21HO1FBQ25CLEVBQUUsT0FBT3hGLE9BQU87WUFDZEosUUFBUSxJQUFJakQsaUJBQWlCdUQsU0FBUyxDQUFDdkQsaUJBQWlCd0QsYUFBYSxDQUFDK0MsZ0JBQWdCLEVBQUVsRCxNQUFNdEIsT0FBTztZQUNyRyxPQUFPK0MsT0FBTzVEO1FBQ2hCO0lBQ0Y7SUFDQSxTQUFTNEosS0FBS3BJLEtBQUssRUFBRThHLGVBQWU7UUFDbEMsTUFBTXVCLGtCQUFrQixFQUFFO1FBQzFCLE1BQU1DLGFBQWEsSUFBSUM7UUFFdkIseUVBQXlFO1FBQ3pFLDRFQUE0RTtRQUM1RSxpQ0FBaUM7UUFDakMsSUFBSXhJLFFBQVE7UUFDWixLQUFLLE1BQU15SSxRQUFReEksTUFBTztZQUN4QixJQUFJeUk7WUFDSixJQUFJLE9BQU9ELFNBQVMsVUFBVTtnQkFDNUJDLGlCQUFpQnJHLE9BQU9yQztnQkFDeEJ1SSxXQUFXNUUsR0FBRyxDQUFDK0UsZ0JBQWdCRDtZQUNqQyxPQUFPO2dCQUNMQyxpQkFBaUJyRyxPQUFPb0c7WUFDMUI7WUFDQUgsZ0JBQWdCSyxJQUFJLENBQUNEO1lBQ3JCMUk7UUFDRjtRQUNBLE9BQU9rSCxrQkFBa0JILGlCQUFpQmpKLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRdUssSUFBSSxFQUN4Ryx1SUFBdUk7UUFDdkluRixDQUFBQTtZQUNFLE1BQU05QyxTQUFTLElBQUkrQyxLQUFLeUYsVUFBVSxDQUFDN0osUUFBUW1FLFNBQVMyRixhQUFhLENBQUNQLGlCQUFpQlEsR0FBRyxDQUFDckosQ0FBQUEsT0FBUUEsS0FBS3NKLElBQUksS0FBSyxZQUFZdEosS0FBS1EsS0FBSyxHQUFHc0ksV0FBVy9GLEdBQUcsQ0FBQy9DLEtBQUtRLEtBQUssS0FBS1IsS0FBS1EsS0FBSztZQUM5SyxJQUFJc0ksV0FBV1MsSUFBSSxHQUFHLEdBQUc7Z0JBQ3ZCLE9BQU81STtZQUNULE9BQU87Z0JBQ0wsT0FBT0EsT0FBT3FILElBQUksQ0FBQztZQUNyQjtRQUNGLEdBQUcsSUFBTXBGLE9BQU9wQztJQUNsQjtJQUNBLE9BQU87UUFDTDFCO1FBQ0FtSjtRQUNBSztRQUNBTTtRQUNBaEI7SUFDRjtBQUNGO0FBRUE0Qiw0QkFBNEIsR0FBRzFIO0FBQy9CMEgsdUJBQXVCLEdBQUczQztBQUMxQjJDLHdCQUF3QixHQUFHOUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmdsaXNoLWNvdXJzZXMvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jcmVhdGVGb3JtYXR0ZXItODFkN2U1OTguanM/YzRhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBJbnRsTWVzc2FnZUZvcm1hdCA9IHJlcXVpcmUoJ2ludGwtbWVzc2FnZWZvcm1hdCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpbml0aWFsaXplQ29uZmlnID0gcmVxdWlyZSgnLi9pbml0aWFsaXplQ29uZmlnLWM1MDNlMjE1LmpzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cblxudmFyIEludGxNZXNzYWdlRm9ybWF0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChJbnRsTWVzc2FnZUZvcm1hdCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbmFtZWQtYXMtZGVmYXVsdCAtLSBGYWxzZSBwb3NpdGl2ZVxuZnVuY3Rpb24gc2V0VGltZVpvbmVJbkZvcm1hdHMoZm9ybWF0cywgdGltZVpvbmUpIHtcbiAgaWYgKCFmb3JtYXRzKSByZXR1cm4gZm9ybWF0cztcblxuICAvLyBUaGUgb25seSB3YXkgdG8gc2V0IGEgdGltZSB6b25lIHdpdGggYGludGwtbWVzc2FnZWZvcm1hdGAgaXMgdG8gbWVyZ2UgaXQgaW50byB0aGUgZm9ybWF0c1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvYmxvYi84MjU2YzUyNzE1MDVjZjI2MDZlNDhlM2M5N2VjZGQxNmVkZTRmMWI1L3BhY2thZ2VzL2ludGwvc3JjL21lc3NhZ2UudHMjTDE1XG4gIHJldHVybiBPYmplY3Qua2V5cyhmb3JtYXRzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSB7XG4gICAgICB0aW1lWm9uZSxcbiAgICAgIC4uLmZvcm1hdHNba2V5XVxuICAgIH07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG4vKipcbiAqIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIHVzZXMgc2VwYXJhdGUga2V5cyBmb3IgYGRhdGVgIGFuZCBgdGltZWAsIGJ1dCB0aGVyZSdzXG4gKiBvbmx5IG9uZSBuYXRpdmUgQVBJOiBgSW50bC5EYXRlVGltZUZvcm1hdGAuIEFkZGl0aW9uYWxseSB5b3UgbWlnaHQgd2FudCB0b1xuICogaW5jbHVkZSBib3RoIGEgdGltZSBhbmQgYSBkYXRlIGluIGEgdmFsdWUsIHRoZXJlZm9yZSB0aGUgc2VwYXJhdGlvbiBkb2Vzbid0XG4gKiBzZWVtIHNvIHVzZWZ1bC4gV2Ugb2ZmZXIgYSBzaW5nbGUgYGRhdGVUaW1lYCBuYW1lc3BhY2UgaW5zdGVhZCwgYnV0IHdlIGhhdmVcbiAqIHRvIGNvbnZlcnQgdGhlIGZvcm1hdCBiZWZvcmUgYGludGwtbWVzc2FnZWZvcm1hdGAgY2FuIGJlIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChmb3JtYXRzLCB0aW1lWm9uZSkge1xuICBjb25zdCBmb3JtYXRzV2l0aFRpbWVab25lID0gdGltZVpvbmUgPyB7XG4gICAgLi4uZm9ybWF0cyxcbiAgICBkYXRlVGltZTogc2V0VGltZVpvbmVJbkZvcm1hdHMoZm9ybWF0cy5kYXRlVGltZSwgdGltZVpvbmUpXG4gIH0gOiBmb3JtYXRzO1xuICBjb25zdCBtZkRhdGVEZWZhdWx0cyA9IEludGxNZXNzYWdlRm9ybWF0X19kZWZhdWx0LmRlZmF1bHQuZm9ybWF0cy5kYXRlO1xuICBjb25zdCBkZWZhdWx0RGF0ZUZvcm1hdHMgPSB0aW1lWm9uZSA/IHNldFRpbWVab25lSW5Gb3JtYXRzKG1mRGF0ZURlZmF1bHRzLCB0aW1lWm9uZSkgOiBtZkRhdGVEZWZhdWx0cztcbiAgY29uc3QgbWZUaW1lRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdF9fZGVmYXVsdC5kZWZhdWx0LmZvcm1hdHMudGltZTtcbiAgY29uc3QgZGVmYXVsdFRpbWVGb3JtYXRzID0gdGltZVpvbmUgPyBzZXRUaW1lWm9uZUluRm9ybWF0cyhtZlRpbWVEZWZhdWx0cywgdGltZVpvbmUpIDogbWZUaW1lRGVmYXVsdHM7XG4gIHJldHVybiB7XG4gICAgLi4uZm9ybWF0c1dpdGhUaW1lWm9uZSxcbiAgICBkYXRlOiB7XG4gICAgICAuLi5kZWZhdWx0RGF0ZUZvcm1hdHMsXG4gICAgICAuLi4oZm9ybWF0c1dpdGhUaW1lWm9uZSA9PT0gbnVsbCB8fCBmb3JtYXRzV2l0aFRpbWVab25lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzV2l0aFRpbWVab25lLmRhdGVUaW1lKVxuICAgIH0sXG4gICAgdGltZToge1xuICAgICAgLi4uZGVmYXVsdFRpbWVGb3JtYXRzLFxuICAgICAgLi4uKGZvcm1hdHNXaXRoVGltZVpvbmUgPT09IG51bGwgfHwgZm9ybWF0c1dpdGhUaW1lWm9uZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0c1dpdGhUaW1lWm9uZS5kYXRlVGltZSlcbiAgICB9XG4gIH07XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbmFtZWQtYXMtZGVmYXVsdCAtLSBGYWxzZSBwb3NpdGl2ZVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpIHtcbiAgY29uc3QgZnVsbEtleSA9IGluaXRpYWxpemVDb25maWcuam9pblBhdGgobmFtZXNwYWNlLCBrZXkpO1xuICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZXMgYXZhaWxhYmxlIGF0IGBcIi5jb25jYXQobmFtZXNwYWNlLCBcImAuXCIpICk7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBtZXNzYWdlcztcbiAga2V5LnNwbGl0KCcuJykuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBjb25zdCBuZXh0ID0gbWVzc2FnZVtwYXJ0XTtcbiAgICBpZiAocGFydCA9PSBudWxsIHx8IG5leHQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgYFwiLmNvbmNhdChmdWxsS2V5LCBcImAgaW4gbWVzc2FnZXMgZm9yIGxvY2FsZSBgXCIpLmNvbmNhdChsb2NhbGUsIFwiYC5cIikgKTtcbiAgICB9XG4gICAgbWVzc2FnZSA9IG5leHQ7XG4gIH0pO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyh2YWx1ZXMpIHtcbiAgaWYgKE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9pc3N1ZXMvMTQ2N1xuICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlcyA9IHt9O1xuICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgbGV0IHRyYW5zZm9ybWVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gY2h1bmtzID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUoY2h1bmtzKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChyZXN1bHQpID8gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChyZXN1bHQsIHtcbiAgICAgICAgICBrZXk6IGtleSArIGluZGV4KytcbiAgICAgICAgfSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHZhbHVlO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1lZFZhbHVlc1trZXldID0gdHJhbnNmb3JtZWQ7XG4gIH0pO1xuICByZXR1cm4gdHJhbnNmb3JtZWRWYWx1ZXM7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlc09yRXJyb3IobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlKSB7XG4gIGxldCBvbkVycm9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRPbkVycm9yO1xuICB0cnkge1xuICAgIGlmICghbWVzc2FnZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1lc3NhZ2VzIHdlcmUgY29uZmlndXJlZCBvbiB0aGUgcHJvdmlkZXIuXCIgKTtcbiAgICB9XG4gICAgY29uc3QgcmV0cmlldmVkTWVzc2FnZXMgPSBuYW1lc3BhY2UgPyByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBuYW1lc3BhY2UpIDogbWVzc2FnZXM7XG4gICAgaWYgKCFyZXRyaWV2ZWRNZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZXMgZm9yIG5hbWVzcGFjZSBgXCIuY29uY2F0KG5hbWVzcGFjZSwgXCJgIGZvdW5kLlwiKSApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0cmlldmVkTWVzc2FnZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgaW50bEVycm9yID0gbmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIG9uRXJyb3IoaW50bEVycm9yKTtcbiAgICByZXR1cm4gaW50bEVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQbGFpbk1lc3NhZ2UoY2FuZGlkYXRlLCB2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgY29uc3QgdW5lc2NhcGVkTWVzc2FnZSA9IGNhbmRpZGF0ZS5yZXBsYWNlKC8nKFt7fV0pL2dpLCAnJDEnKTtcblxuICAvLyBQbGFjZWhvbGRlcnMgY2FuIGJlIGluIHRoZSBtZXNzYWdlIGlmIHRoZXJlIGFyZSBkZWZhdWx0IHZhbHVlcyxcbiAgLy8gb3IgaWYgdGhlIHVzZXIgaGFzIGZvcmdvdHRlbiB0byBwcm92aWRlIHZhbHVlcy4gSW4gdGhlIGxhdHRlclxuICAvLyBjYXNlIHdlIG5lZWQgdG8gY29tcGlsZSB0aGUgbWVzc2FnZSB0byByZWNlaXZlIGFuIGVycm9yLlxuICBjb25zdCBoYXNQbGFjZWhvbGRlcnMgPSAvPHx7Ly50ZXN0KHVuZXNjYXBlZE1lc3NhZ2UpO1xuICBpZiAoIWhhc1BsYWNlaG9sZGVycykge1xuICAgIHJldHVybiB1bmVzY2FwZWRNZXNzYWdlO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvcihjb25maWcpIHtcbiAgY29uc3QgbWVzc2FnZXNPckVycm9yID0gZ2V0TWVzc2FnZXNPckVycm9yKGNvbmZpZy5sb2NhbGUsIGNvbmZpZy5tZXNzYWdlcywgY29uZmlnLm5hbWVzcGFjZSwgY29uZmlnLm9uRXJyb3IpO1xuICByZXR1cm4gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgICAuLi5jb25maWcsXG4gICAgbWVzc2FnZXNPckVycm9yXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgZm9ybWF0czogZ2xvYmFsRm9ybWF0cyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2sgPSBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbG9jYWxlLFxuICAgIG1lc3NhZ2VGb3JtYXRDYWNoZSxcbiAgICBtZXNzYWdlc09yRXJyb3IsXG4gICAgbmFtZXNwYWNlLFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmVcbiAgfSA9IF9yZWY7XG4gIGZ1bmN0aW9uIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgY29kZSwgbWVzc2FnZSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGNvZGUsIG1lc3NhZ2UpO1xuICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgZXJyb3IsXG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2xhdGVCYXNlRm4oIC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgaWYgKG1lc3NhZ2VzT3JFcnJvciBpbnN0YW5jZW9mIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0IHRoaXMgZHVyaW5nIHJlbmRlclxuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgIG1lc3NhZ2UgPSByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZUtleSA9IGluaXRpYWxpemVDb25maWcuam9pblBhdGgobG9jYWxlLCBuYW1lc3BhY2UsIGtleSwgU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICBsZXQgbWVzc2FnZUZvcm1hdDtcbiAgICBpZiAobWVzc2FnZUZvcm1hdENhY2hlICE9PSBudWxsICYmIG1lc3NhZ2VGb3JtYXRDYWNoZSAhPT0gdm9pZCAwICYmIG1lc3NhZ2VGb3JtYXRDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICBtZXNzYWdlRm9ybWF0ID0gbWVzc2FnZUZvcm1hdENhY2hlLmdldChjYWNoZUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbGV0IGNvZGUsIGVycm9yTWVzc2FnZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgICBjb2RlID0gaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIk1lc3NhZ2UgYXQgYFwiLmNvbmNhdChpbml0aWFsaXplQ29uZmlnLmpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KSwgXCJgIHJlc29sdmVkIHRvIGFuIGFycmF5LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFNlZSBodHRwczovL25leHQtaW50bC1kb2NzLnZlcmNlbC5hcHAvZG9jcy91c2FnZS9tZXNzYWdlcyNhcnJheXMtb2YtbWVzc2FnZXNcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGUgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5TVUZGSUNJRU5UX1BBVEg7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJNZXNzYWdlIGF0IGBcIi5jb25jYXQoaW5pdGlhbGl6ZUNvbmZpZy5qb2luUGF0aChuYW1lc3BhY2UsIGtleSksIFwiYCByZXNvbHZlZCB0byBhbiBvYmplY3QsIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gVXNlIGEgYC5gIHRvIHJldHJpZXZlIG5lc3RlZCBtZXNzYWdlcy4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL3VzYWdlL21lc3NhZ2VzI3N0cnVjdHVyaW5nLW1lc3NhZ2VzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBIb3QgcGF0aCB0aGF0IGF2b2lkcyBjcmVhdGluZyBhbiBgSW50bE1lc3NhZ2VGb3JtYXRgIGluc3RhbmNlXG4gICAgICBjb25zdCBwbGFpbk1lc3NhZ2UgPSBnZXRQbGFpbk1lc3NhZ2UobWVzc2FnZSwgdmFsdWVzKTtcbiAgICAgIGlmIChwbGFpbk1lc3NhZ2UpIHJldHVybiBwbGFpbk1lc3NhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlRm9ybWF0ID0gbmV3IEludGxNZXNzYWdlRm9ybWF0X19kZWZhdWx0LmRlZmF1bHQobWVzc2FnZSwgbG9jYWxlLCBjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQoe1xuICAgICAgICAgIC4uLmdsb2JhbEZvcm1hdHMsXG4gICAgICAgICAgLi4uZm9ybWF0c1xuICAgICAgICB9LCB0aW1lWm9uZSksIHtcbiAgICAgICAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgICAgICBnZXROdW1iZXJGb3JtYXQobG9jYWxlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy80Mjc5XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGVzLCB7XG4gICAgICAgICAgICAgICAgdGltZVpvbmUsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQbHVyYWxSdWxlcyhsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5QbHVyYWxSdWxlcyhsb2NhbGVzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdGhyb3duRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRSwgdGhyb3duRXJyb3IubWVzc2FnZSArICgnb3JpZ2luYWxNZXNzYWdlJyBpbiB0aHJvd25FcnJvciA/IFwiIChcIi5jb25jYXQodGhyb3duRXJyb3Iub3JpZ2luYWxNZXNzYWdlLCBcIilcIikgOiAnJykgKTtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2VGb3JtYXRDYWNoZSA9PT0gbnVsbCB8fCBtZXNzYWdlRm9ybWF0Q2FjaGUgPT09IHZvaWQgMCB8fCBtZXNzYWdlRm9ybWF0Q2FjaGUuc2V0KGNhY2hlS2V5LCBtZXNzYWdlRm9ybWF0KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSBtZXNzYWdlRm9ybWF0LmZvcm1hdChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGludGwtbWVzc2FnZWZvcm1hdGAgZXhwZWN0cyBhIGRpZmZlcmVudCBmb3JtYXRcbiAgICAgIC8vIGZvciByaWNoIHRleHQgZWxlbWVudHMgc2luY2UgYSByZWNlbnQgbWlub3IgdXBkYXRlLiBUaGlzXG4gICAgICAvLyBuZWVkcyB0byBiZSBldmFsdWF0ZWQgaW4gZGV0YWlsLCBwb3NzaWJseSBhbHNvIGluIHJlZ2FyZHNcbiAgICAgIC8vIHRvIGJlIGFibGUgdG8gZm9ybWF0IHRvIHBhcnRzLlxuICAgICAgcHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzKHtcbiAgICAgICAgLi4uZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzLFxuICAgICAgICAuLi52YWx1ZXNcbiAgICAgIH0pKTtcbiAgICAgIGlmIChmb3JtYXR0ZWRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZvcm1hdCBgXCIuY29uY2F0KGtleSwgXCJgIGluIFwiKS5jb25jYXQobmFtZXNwYWNlID8gXCJuYW1lc3BhY2UgYFwiLmNvbmNhdChuYW1lc3BhY2UsIFwiYFwiKSA6ICdtZXNzYWdlcycpICk7XG4gICAgICB9XG5cbiAgICAgIC8vIExpbWl0IHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgdG8gcmV0dXJuIHN0cmluZ3Mgb3IgUmVhY3QgZWxlbWVudHNcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoZm9ybWF0dGVkTWVzc2FnZSkgfHxcbiAgICAgIC8vIEFycmF5cyBvZiBSZWFjdCBlbGVtZW50c1xuICAgICAgQXJyYXkuaXNBcnJheShmb3JtYXR0ZWRNZXNzYWdlKSB8fCB0eXBlb2YgZm9ybWF0dGVkTWVzc2FnZSA9PT0gJ3N0cmluZycgPyBmb3JtYXR0ZWRNZXNzYWdlIDogU3RyaW5nKGZvcm1hdHRlZE1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUZuKCAvKiogVXNlIGEgZG90IHRvIGluZGljYXRlIGEgbGV2ZWwgb2YgbmVzdGluZyAoZS5nLiBgbmFtZXNwYWNlLm5lc3RlZExhYmVsYCkuICovXG4gIGtleSwgLyoqIEtleSB2YWx1ZSBwYWlycyBmb3IgdmFsdWVzIHRvIGludGVycG9sYXRlIGludG8gdGhlIG1lc3NhZ2UuICovXG4gIHZhbHVlcywgLyoqIFByb3ZpZGUgY3VzdG9tIGZvcm1hdHMgZm9yIG51bWJlcnMsIGRhdGVzIGFuZCB0aW1lcy4gKi9cbiAgZm9ybWF0cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZUJhc2VGbihrZXksIHZhbHVlcywgZm9ybWF0cyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCBcIlRoZSBtZXNzYWdlIGBcIi5jb25jYXQoa2V5LCBcImAgaW4gXCIpLmNvbmNhdChuYW1lc3BhY2UgPyBcIm5hbWVzcGFjZSBgXCIuY29uY2F0KG5hbWVzcGFjZSwgXCJgXCIpIDogJ21lc3NhZ2VzJywgXCIgZGlkbid0IHJlc29sdmUgdG8gYSBzdHJpbmcuIElmIHlvdSB3YW50IHRvIGZvcm1hdCByaWNoIHRleHQsIHVzZSBgdC5yaWNoYCBpbnN0ZWFkLlwiKSApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRyYW5zbGF0ZUZuLnJpY2ggPSB0cmFuc2xhdGVCYXNlRm47XG5cbiAgLy8gQXVnbWVudCBgdHJhbnNsYXRlQmFzZUZuYCB0byByZXR1cm4gcGxhaW4gc3RyaW5nc1xuICB0cmFuc2xhdGVGbi5tYXJrdXAgPSAoa2V5LCB2YWx1ZXMsIGZvcm1hdHMpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc2xhdGVCYXNlRm4oa2V5LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gYE1hcmt1cFRyYW5zbGF0aW9uVmFsdWVzYCBpcyBwcmFjdGljYWxseSBhIHN1YiB0eXBlXG4gICAgLy8gb2YgYFJpY2hUcmFuc2xhdGlvblZhbHVlc2AgYnV0IFR5cGVTY3JpcHQgaXNuJ3Qgc21hcnQgZW5vdWdoIGhlcmUuXG4gICAgdmFsdWVzLCBmb3JtYXRzKTtcblxuICAgIC8vIFdoZW4gb25seSBzdHJpbmcgY2h1bmtzIGFyZSBwcm92aWRlZCB0byB0aGUgcGFyc2VyLCBvbmx5XG4gICAgLy8gc3RyaW5ncyBzaG91bGQgYmUgcmV0dXJuZWQgaGVyZS4gTm90ZSB0aGF0IHdlIG5lZWQgYSBydW50aW1lXG4gICAgLy8gY2hlY2sgZm9yIHRoaXMgc2luY2UgcmljaCB0ZXh0IHZhbHVlcyBjb3VsZCBiZSBhY2NpZGVudGFsbHlcbiAgICAvLyBpbmhlcml0ZWQgZnJvbSBgZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzYC5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBcImB0Lm1hcmt1cGAgb25seSBhY2NlcHRzIGZ1bmN0aW9ucyBmb3IgZm9ybWF0dGluZyB0aGF0IHJlY2VpdmUgYW5kIHJldHVybiBzdHJpbmdzLlxcblxcbkUuZy4gdC5tYXJrdXAoJ21hcmt1cCcsIHtiOiAoY2h1bmtzKSA9PiBgPGI+JHtjaHVua3N9PC9iPmB9KVwiICk7XG4gICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICB0cmFuc2xhdGVGbi5yYXcgPSBrZXkgPT4ge1xuICAgIGlmIChtZXNzYWdlc09yRXJyb3IgaW5zdGFuY2VvZiBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcikge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dCB0aGlzIGR1cmluZyByZW5kZXJcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNPckVycm9yO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFuc2xhdGVGbjtcbn1cblxuLyoqXG4gKiBGb3IgdGhlIHN0cmljdGx5IHR5cGVkIG1lc3NhZ2VzIHRvIHdvcmsgd2UgaGF2ZSB0byB3cmFwIHRoZSBuYW1lc3BhY2UgaW50b1xuICogYSBtYW5kYXRvcnkgcHJlZml4LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICovXG5mdW5jdGlvbiByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIHJldHVybiBuYW1lc3BhY2UgPT09IG5hbWVzcGFjZVByZWZpeCA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZS5zbGljZSgobmFtZXNwYWNlUHJlZml4ICsgJy4nKS5sZW5ndGgpO1xufVxuXG5jb25zdCBTRUNPTkQgPSAxO1xuY29uc3QgTUlOVVRFID0gU0VDT05EICogNjA7XG5jb25zdCBIT1VSID0gTUlOVVRFICogNjA7XG5jb25zdCBEQVkgPSBIT1VSICogMjQ7XG5jb25zdCBXRUVLID0gREFZICogNztcbmNvbnN0IE1PTlRIID0gREFZICogKDM2NSAvIDEyKTsgLy8gQXBwcm94aW1hdGlvblxuY29uc3QgUVVBUlRFUiA9IE1PTlRIICogMztcbmNvbnN0IFlFQVIgPSBEQVkgKiAzNjU7XG5jb25zdCBVTklUX1NFQ09ORFMgPSB7XG4gIHNlY29uZDogU0VDT05ELFxuICBzZWNvbmRzOiBTRUNPTkQsXG4gIG1pbnV0ZTogTUlOVVRFLFxuICBtaW51dGVzOiBNSU5VVEUsXG4gIGhvdXI6IEhPVVIsXG4gIGhvdXJzOiBIT1VSLFxuICBkYXk6IERBWSxcbiAgZGF5czogREFZLFxuICB3ZWVrOiBXRUVLLFxuICB3ZWVrczogV0VFSyxcbiAgbW9udGg6IE1PTlRILFxuICBtb250aHM6IE1PTlRILFxuICBxdWFydGVyOiBRVUFSVEVSLFxuICBxdWFydGVyczogUVVBUlRFUixcbiAgeWVhcjogWUVBUixcbiAgeWVhcnM6IFlFQVJcbn07XG5mdW5jdGlvbiByZXNvbHZlUmVsYXRpdmVUaW1lVW5pdChzZWNvbmRzKSB7XG4gIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnMoc2Vjb25kcyk7XG4gIGlmIChhYnNWYWx1ZSA8IE1JTlVURSkge1xuICAgIHJldHVybiAnc2Vjb25kJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IEhPVVIpIHtcbiAgICByZXR1cm4gJ21pbnV0ZSc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBEQVkpIHtcbiAgICByZXR1cm4gJ2hvdXInO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgV0VFSykge1xuICAgIHJldHVybiAnZGF5JztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IE1PTlRIKSB7XG4gICAgcmV0dXJuICd3ZWVrJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IFlFQVIpIHtcbiAgICByZXR1cm4gJ21vbnRoJztcbiAgfVxuICByZXR1cm4gJ3llYXInO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCkge1xuICAvLyBXZSBoYXZlIHRvIHJvdW5kIHRoZSByZXN1bHRpbmcgdmFsdWVzLCBhcyBgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXRgXG4gIC8vIHdpbGwgaW5jbHVkZSBmcmFjdGlvbnMgbGlrZSAnMi4xIGhvdXJzIGFnbycuXG4gIHJldHVybiBNYXRoLnJvdW5kKHNlY29uZHMgLyBVTklUX1NFQ09ORFNbdW5pdF0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBmb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICBub3c6IGdsb2JhbE5vdyxcbiAgICBvbkVycm9yID0gaW5pdGlhbGl6ZUNvbmZpZy5kZWZhdWx0T25FcnJvcixcbiAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgfSA9IF9yZWY7XG4gIGZ1bmN0aW9uIGFwcGx5VGltZVpvbmUob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucztcbiAgICBpZiAoISgoX29wdGlvbnMgPSBvcHRpb25zKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyAhPT0gdm9pZCAwICYmIF9vcHRpb25zLnRpbWVab25lKSkge1xuICAgICAgaWYgKGdsb2JhbFRpbWVab25lKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgXCJUaGUgYHRpbWVab25lYCBwYXJhbWV0ZXIgd2Fzbid0IHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdCB0byBhdm9pZCBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL2NvbmZpZ3VyYXRpb24jdGltZS16b25lXCIgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucykge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgZm9ybWF0T3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZm9ybWF0TmFtZSA9IGZvcm1hdE9yT3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB0eXBlRm9ybWF0cyA9PT0gbnVsbCB8fCB0eXBlRm9ybWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHlwZUZvcm1hdHNbZm9ybWF0TmFtZV07XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLk1JU1NJTkdfRk9STUFULCBcIkZvcm1hdCBgXCIuY29uY2F0KGZvcm1hdE5hbWUsIFwiYCBpcyBub3QgYXZhaWxhYmxlLiBZb3UgY2FuIGNvbmZpZ3VyZSBpdCBvbiB0aGUgcHJvdmlkZXIgb3IgcHJvdmlkZSBjdXN0b20gb3B0aW9ucy5cIikgKTtcbiAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gZm9ybWF0T3JPcHRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIHR5cGVGb3JtYXRzLCBmb3JtYXR0ZXIsIGdldEZhbGxiYWNrKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSByZXNvbHZlRm9ybWF0T3JPcHRpb25zKHR5cGVGb3JtYXRzLCBmb3JtYXRPck9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWUoIC8qKiBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgdGhpcyBpcyBpbnRlcnByZXRlZCBhcyBhIFVUQyB0aW1lc3RhbXAuICovXG4gIHZhbHVlLFxuICAvKiogSWYgYSB0aW1lIHpvbmUgaXMgc3VwcGxpZWQsIHRoZSBgdmFsdWVgIGlzIGNvbnZlcnRlZCB0byB0aGF0IHRpbWUgem9uZS5cbiAgICogT3RoZXJ3aXNlIHRoZSB1c2VyIHRpbWUgem9uZSB3aWxsIGJlIHVzZWQuICovXG4gIGZvcm1hdE9yT3B0aW9ucykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIGZvcm1hdHMgPT09IG51bGwgfHwgZm9ybWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0cy5kYXRlVGltZSwgb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zID0gYXBwbHlUaW1lWm9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWVSYW5nZSggLyoqIElmIGEgbnVtYmVyIGlzIHN1cHBsaWVkLCB0aGlzIGlzIGludGVycHJldGVkIGFzIGEgVVRDIHRpbWVzdGFtcC4gKi9cbiAgc3RhcnQsIC8qKiBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgdGhpcyBpcyBpbnRlcnByZXRlZCBhcyBhIFVUQyB0aW1lc3RhbXAuICovXG4gIGVuZCxcbiAgLyoqIElmIGEgdGltZSB6b25lIGlzIHN1cHBsaWVkLCB0aGUgdmFsdWVzIGFyZSBjb252ZXJ0ZWQgdG8gdGhhdCB0aW1lIHpvbmUuXG4gICAqIE90aGVyd2lzZSB0aGUgdXNlciB0aW1lIHpvbmUgd2lsbCBiZSB1c2VkLiAqL1xuICBmb3JtYXRPck9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBmb3JtYXRzID09PSBudWxsIHx8IGZvcm1hdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHMuZGF0ZVRpbWUsIG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucyA9IGFwcGx5VGltZVpvbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXRSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9LCAoKSA9PiBbZGF0ZVRpbWUoc3RhcnQpLCBkYXRlVGltZShlbmQpXS5qb2luKCfigInigJPigIknKSk7XG4gIH1cbiAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBmb3JtYXRzID09PSBudWxsIHx8IGZvcm1hdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHMubnVtYmVyLCBvcHRpb25zID0+IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSksICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEdsb2JhbE5vdygpIHtcbiAgICBpZiAoZ2xvYmFsTm93KSB7XG4gICAgICByZXR1cm4gZ2xvYmFsTm93O1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkVycm9yKG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIFwiVGhlIGBub3dgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0IHRvIGF2b2lkIG1hcmt1cCBtaXNtYXRjaGVzIGNhdXNlZCBieSBlbnZpcm9ubWVudCBkaWZmZXJlbmNlcy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0LWludGwtZG9jcy52ZXJjZWwuYXBwL2RvY3MvY29uZmlndXJhdGlvbiNub3dcIiApKTtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0Tm93RGF0ZShub3dPck9wdGlvbnMpIHtcbiAgICBpZiAobm93T3JPcHRpb25zIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2Ygbm93T3JPcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKG5vd09yT3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICgobm93T3JPcHRpb25zID09PSBudWxsIHx8IG5vd09yT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm93T3JPcHRpb25zLm5vdykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKG5vd09yT3B0aW9ucy5ub3cpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0R2xvYmFsTm93KCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKCAvKiogVGhlIGRhdGUgdGltZSB0aGF0IG5lZWRzIHRvIGJlIGZvcm1hdHRlZC4gKi9cbiAgZGF0ZSwgLyoqIFRoZSByZWZlcmVuY2UgcG9pbnQgaW4gdGltZSB0byB3aGljaCBgZGF0ZWAgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gcmVsYXRpb24gdG8uICAqL1xuICBub3dPck9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0ZURhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIGNvbnN0IG5vd0RhdGUgPSBleHRyYWN0Tm93RGF0ZShub3dPck9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2Vjb25kcyA9IChkYXRlRGF0ZS5nZXRUaW1lKCkgLSBub3dEYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgICAgY29uc3QgdW5pdCA9IHR5cGVvZiBub3dPck9wdGlvbnMgPT09ICdudW1iZXInIHx8IG5vd09yT3B0aW9ucyBpbnN0YW5jZW9mIERhdGUgfHwgKG5vd09yT3B0aW9ucyA9PT0gbnVsbCB8fCBub3dPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vd09yT3B0aW9ucy51bml0KSA9PT0gdW5kZWZpbmVkID8gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcykgOiBub3dPck9wdGlvbnMudW5pdDtcbiAgICAgIGNvbnN0IHZhbHVlID0gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCk7XG4gICAgICByZXR1cm4gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY2FsZSwge1xuICAgICAgICAvLyBgbnVtZXJpYzogJ2F1dG8nYCBjYW4gdGhlb3JldGljYWxseSBwcm9kdWNlIG91dHB1dCBsaWtlIFwieWVzdGVyZGF5XCIsXG4gICAgICAgIC8vIGJ1dCBpdCBvbmx5IHdvcmtzIHdpdGggaW50ZWdlcnMuIEUuZy4gLTEgZGF5IHdpbGwgcHJvZHVjZSBcInllc3RlcmRheVwiLFxuICAgICAgICAvLyBidXQgLTEuMSBkYXlzIHdpbGwgcHJvZHVjZSBcIi0xLjEgZGF5c1wiLiBSb3VuZGluZyBiZWZvcmUgZm9ybWF0dGluZyBpc1xuICAgICAgICAvLyBub3QgZGVzaXJlZCwgYXMgdGhlIGdpdmVuIGRhdGVzIG1pZ2h0IGNyb3NzIGEgdGhyZXNob2xkIHdlcmUgdGhlXG4gICAgICAgIC8vIG91dHB1dCBpc24ndCBjb3JyZWN0IGFueW1vcmUuIEV4YW1wbGU6IDIwMjQtMDEtMDhUMjM6MDA6MDAuMDAwWiBhbmRcbiAgICAgICAgLy8gMjAyNC0wMS0wOFQwMTowMDowMC4wMDBaIHdvdWxkIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIiwgd2hpY2ggaXMgbm90IHRoZVxuICAgICAgICAvLyBjYXNlLiBCeSB1c2luZyBgYWx3YXlzYCB3ZSBjYW4gZW5zdXJlIGNvcnJlY3Qgb3V0cHV0LiBUaGUgb25seSBleGNlcHRpb25cbiAgICAgICAgLy8gaXMgdGhlIGZvcm1hdHRpbmcgb2YgdGltZXMgPDEgc2Vjb25kIGFzIFwibm93XCIuXG4gICAgICAgIG51bWVyaWM6IHVuaXQgPT09ICdzZWNvbmQnID8gJ2F1dG8nIDogJ2Fsd2F5cydcbiAgICAgIH0pLmZvcm1hdCh2YWx1ZSwgdW5pdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICByZXR1cm4gU3RyaW5nKGRhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsaXN0KHZhbHVlLCBmb3JtYXRPck9wdGlvbnMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVmFsdWUgPSBbXTtcbiAgICBjb25zdCByaWNoVmFsdWVzID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gYGZvcm1hdFRvUGFydHNgIG9ubHkgYWNjZXB0cyBzdHJpbmdzLCB0aGVyZWZvcmUgd2UgaGF2ZSB0byB0ZW1wb3JhcmlseVxuICAgIC8vIHJlcGxhY2UgUmVhY3QgZWxlbWVudHMgd2l0aCBhIHBsYWNlaG9sZGVyIElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmV0cmlldmVcbiAgICAvLyB0aGUgb3JpZ2luYWwgdmFsdWUgYWZ0ZXJ3YXJkcy5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgbGV0IHNlcmlhbGl6ZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgIHJpY2hWYWx1ZXMuc2V0KHNlcmlhbGl6ZWRJdGVtLCBpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWRJdGVtID0gU3RyaW5nKGl0ZW0pO1xuICAgICAgfVxuICAgICAgc2VyaWFsaXplZFZhbHVlLnB1c2goc2VyaWFsaXplZEl0ZW0pO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgZm9ybWF0cyA9PT0gbnVsbCB8fCBmb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzLmxpc3QsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgcmljaFZhbHVlcy5zaXplYCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgcmV0dXJuIHR5cGUsIGJ1dCBUeXBlU2NyaXB0IGNhbid0IGluZmVyIHRoZSBtZWFuaW5nIG9mIHRoaXMgY29ycmVjdGx5XG4gICAgb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhzZXJpYWxpemVkVmFsdWUpLm1hcChwYXJ0ID0+IHBhcnQudHlwZSA9PT0gJ2xpdGVyYWwnID8gcGFydC52YWx1ZSA6IHJpY2hWYWx1ZXMuZ2V0KHBhcnQudmFsdWUpIHx8IHBhcnQudmFsdWUpO1xuICAgICAgaWYgKHJpY2hWYWx1ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZSxcbiAgICBudW1iZXIsXG4gICAgcmVsYXRpdmVUaW1lLFxuICAgIGxpc3QsXG4gICAgZGF0ZVRpbWVSYW5nZVxuICB9O1xufVxuXG5leHBvcnRzLmNyZWF0ZUJhc2VUcmFuc2xhdG9yID0gY3JlYXRlQmFzZVRyYW5zbGF0b3I7XG5leHBvcnRzLmNyZWF0ZUZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcjtcbmV4cG9ydHMucmVzb2x2ZU5hbWVzcGFjZSA9IHJlc29sdmVOYW1lc3BhY2U7XG4iXSwibmFtZXMiOlsiSW50bE1lc3NhZ2VGb3JtYXQiLCJyZXF1aXJlIiwiUmVhY3QiLCJpbml0aWFsaXplQ29uZmlnIiwiX2ludGVyb3BEZWZhdWx0IiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQiLCJzZXRUaW1lWm9uZUluRm9ybWF0cyIsImZvcm1hdHMiLCJ0aW1lWm9uZSIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQiLCJmb3JtYXRzV2l0aFRpbWVab25lIiwiZGF0ZVRpbWUiLCJtZkRhdGVEZWZhdWx0cyIsImRhdGUiLCJkZWZhdWx0RGF0ZUZvcm1hdHMiLCJtZlRpbWVEZWZhdWx0cyIsInRpbWUiLCJkZWZhdWx0VGltZUZvcm1hdHMiLCJyZXNvbHZlUGF0aCIsImxvY2FsZSIsIm1lc3NhZ2VzIiwibmFtZXNwYWNlIiwiZnVsbEtleSIsImpvaW5QYXRoIiwiRXJyb3IiLCJjb25jYXQiLCJtZXNzYWdlIiwic3BsaXQiLCJmb3JFYWNoIiwicGFydCIsIm5leHQiLCJwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXMiLCJ2YWx1ZXMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJ0cmFuc2Zvcm1lZFZhbHVlcyIsImluZGV4IiwidmFsdWUiLCJ0cmFuc2Zvcm1lZCIsImNodW5rcyIsInJlc3VsdCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiZ2V0TWVzc2FnZXNPckVycm9yIiwib25FcnJvciIsImFyZ3VtZW50cyIsImRlZmF1bHRPbkVycm9yIiwicmV0cmlldmVkTWVzc2FnZXMiLCJlcnJvciIsImludGxFcnJvciIsIkludGxFcnJvciIsIkludGxFcnJvckNvZGUiLCJNSVNTSU5HX01FU1NBR0UiLCJnZXRQbGFpbk1lc3NhZ2UiLCJjYW5kaWRhdGUiLCJ1bmVzY2FwZWRNZXNzYWdlIiwicmVwbGFjZSIsImhhc1BsYWNlaG9sZGVycyIsInRlc3QiLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsImNvbmZpZyIsIm1lc3NhZ2VzT3JFcnJvciIsImNyZWF0ZUJhc2VUcmFuc2xhdG9ySW1wbCIsIl9yZWYiLCJkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMiLCJnbG9iYWxGb3JtYXRzIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwiZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayIsIm1lc3NhZ2VGb3JtYXRDYWNoZSIsImdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5IiwiY29kZSIsInRyYW5zbGF0ZUJhc2VGbiIsImNhY2hlS2V5IiwiU3RyaW5nIiwibWVzc2FnZUZvcm1hdCIsImhhcyIsImdldCIsImVycm9yTWVzc2FnZSIsIkFycmF5IiwiaXNBcnJheSIsIklOVkFMSURfTUVTU0FHRSIsIklOU1VGRklDSUVOVF9QQVRIIiwicGxhaW5NZXNzYWdlIiwiZm9ybWF0dGVycyIsImdldE51bWJlckZvcm1hdCIsImxvY2FsZXMiLCJvcHRpb25zIiwiSW50bCIsIk51bWJlckZvcm1hdCIsImdldERhdGVUaW1lRm9ybWF0IiwiRGF0ZVRpbWVGb3JtYXQiLCJnZXRQbHVyYWxSdWxlcyIsIlBsdXJhbFJ1bGVzIiwidGhyb3duRXJyb3IiLCJvcmlnaW5hbE1lc3NhZ2UiLCJzZXQiLCJmb3JtYXR0ZWRNZXNzYWdlIiwiZm9ybWF0IiwiRk9STUFUVElOR19FUlJPUiIsInRyYW5zbGF0ZUZuIiwicmljaCIsIm1hcmt1cCIsInJhdyIsInJlc29sdmVOYW1lc3BhY2UiLCJuYW1lc3BhY2VQcmVmaXgiLCJzbGljZSIsIlNFQ09ORCIsIk1JTlVURSIsIkhPVVIiLCJEQVkiLCJXRUVLIiwiTU9OVEgiLCJRVUFSVEVSIiwiWUVBUiIsIlVOSVRfU0VDT05EUyIsInNlY29uZCIsInNlY29uZHMiLCJtaW51dGUiLCJtaW51dGVzIiwiaG91ciIsImhvdXJzIiwiZGF5IiwiZGF5cyIsIndlZWsiLCJ3ZWVrcyIsIm1vbnRoIiwibW9udGhzIiwicXVhcnRlciIsInF1YXJ0ZXJzIiwieWVhciIsInllYXJzIiwicmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQiLCJhYnNWYWx1ZSIsIk1hdGgiLCJhYnMiLCJjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZSIsInVuaXQiLCJyb3VuZCIsImNyZWF0ZUZvcm1hdHRlciIsIm5vdyIsImdsb2JhbE5vdyIsImdsb2JhbFRpbWVab25lIiwiYXBwbHlUaW1lWm9uZSIsIl9vcHRpb25zIiwiRU5WSVJPTk1FTlRfRkFMTEJBQ0siLCJyZXNvbHZlRm9ybWF0T3JPcHRpb25zIiwidHlwZUZvcm1hdHMiLCJmb3JtYXRPck9wdGlvbnMiLCJmb3JtYXROYW1lIiwiTUlTU0lOR19GT1JNQVQiLCJnZXRGb3JtYXR0ZWRWYWx1ZSIsImZvcm1hdHRlciIsImdldEZhbGxiYWNrIiwiZGF0ZVRpbWVSYW5nZSIsInN0YXJ0IiwiZW5kIiwiZm9ybWF0UmFuZ2UiLCJqb2luIiwibnVtYmVyIiwiZ2V0R2xvYmFsTm93IiwiRGF0ZSIsImV4dHJhY3ROb3dEYXRlIiwibm93T3JPcHRpb25zIiwicmVsYXRpdmVUaW1lIiwiZGF0ZURhdGUiLCJub3dEYXRlIiwiZ2V0VGltZSIsIlJlbGF0aXZlVGltZUZvcm1hdCIsIm51bWVyaWMiLCJsaXN0Iiwic2VyaWFsaXplZFZhbHVlIiwicmljaFZhbHVlcyIsIk1hcCIsIml0ZW0iLCJzZXJpYWxpemVkSXRlbSIsInB1c2giLCJMaXN0Rm9ybWF0IiwiZm9ybWF0VG9QYXJ0cyIsIm1hcCIsInR5cGUiLCJzaXplIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/createFormatter-81d7e598.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nvar core = __webpack_require__(/*! ./core.js */ \"(ssr)/./node_modules/use-intl/dist/development/core.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-81d7e598.js */ \"(ssr)/./node_modules/use-intl/dist/development/createFormatter-81d7e598.js\");\nvar _IntlProvider = __webpack_require__(/*! ./_IntlProvider.js */ \"(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\");\nvar react = __webpack_require__(/*! ./react.js */ \"(ssr)/./node_modules/use-intl/dist/development/react.js\");\nvar _useLocale = __webpack_require__(/*! ./_useLocale-321e619f.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale-321e619f.js\");\n__webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\n__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n__webpack_require__(/*! ./IntlContext-b5cc6be8.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\");\nexports.IntlError = initializeConfig.IntlError;\nexports.IntlErrorCode = initializeConfig.IntlErrorCode;\nexports.initializeConfig = initializeConfig.initializeConfig;\nexports.createTranslator = core.createTranslator;\nexports.createFormatter = createFormatter.createFormatter;\nexports.IntlProvider = _IntlProvider.IntlProvider;\nexports.useFormatter = react.useFormatter;\nexports.useMessages = react.useMessages;\nexports.useNow = react.useNow;\nexports.useTimeZone = react.useTimeZone;\nexports.useTranslations = react.useTranslations;\nexports.useLocale = _useLocale.useLocale;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxtQkFBbUJDLG1CQUFPQSxDQUFDO0FBQy9CLElBQUlDLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ25CLElBQUlFLGtCQUFrQkYsbUJBQU9BLENBQUM7QUFDOUIsSUFBSUcsZ0JBQWdCSCxtQkFBT0EsQ0FBQztBQUM1QixJQUFJSSxRQUFRSixtQkFBT0EsQ0FBQztBQUNwQixJQUFJSyxhQUFhTCxtQkFBT0EsQ0FBQztBQUN6QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFJUkgsaUJBQWlCLEdBQUdFLGlCQUFpQk8sU0FBUztBQUM5Q1QscUJBQXFCLEdBQUdFLGlCQUFpQlEsYUFBYTtBQUN0RFYsd0JBQXdCLEdBQUdFLGlCQUFpQkEsZ0JBQWdCO0FBQzVERix3QkFBd0IsR0FBR0ksS0FBS08sZ0JBQWdCO0FBQ2hEWCx1QkFBdUIsR0FBR0ssZ0JBQWdCQSxlQUFlO0FBQ3pETCxvQkFBb0IsR0FBR00sY0FBY00sWUFBWTtBQUNqRFosb0JBQW9CLEdBQUdPLE1BQU1NLFlBQVk7QUFDekNiLG1CQUFtQixHQUFHTyxNQUFNTyxXQUFXO0FBQ3ZDZCxjQUFjLEdBQUdPLE1BQU1RLE1BQU07QUFDN0JmLG1CQUFtQixHQUFHTyxNQUFNUyxXQUFXO0FBQ3ZDaEIsdUJBQXVCLEdBQUdPLE1BQU1VLGVBQWU7QUFDL0NqQixpQkFBaUIsR0FBR1EsV0FBV1UsU0FBUyIsInNvdXJjZXMiOlsid2VicGFjazovL2VuZ2xpc2gtY291cnNlcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2RldmVsb3BtZW50L2luZGV4LmpzPzk1ZjkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgaW5pdGlhbGl6ZUNvbmZpZyA9IHJlcXVpcmUoJy4vaW5pdGlhbGl6ZUNvbmZpZy1jNTAzZTIxNS5qcycpO1xudmFyIGNvcmUgPSByZXF1aXJlKCcuL2NvcmUuanMnKTtcbnZhciBjcmVhdGVGb3JtYXR0ZXIgPSByZXF1aXJlKCcuL2NyZWF0ZUZvcm1hdHRlci04MWQ3ZTU5OC5qcycpO1xudmFyIF9JbnRsUHJvdmlkZXIgPSByZXF1aXJlKCcuL19JbnRsUHJvdmlkZXIuanMnKTtcbnZhciByZWFjdCA9IHJlcXVpcmUoJy4vcmVhY3QuanMnKTtcbnZhciBfdXNlTG9jYWxlID0gcmVxdWlyZSgnLi9fdXNlTG9jYWxlLTMyMWU2MTlmLmpzJyk7XG5yZXF1aXJlKCdpbnRsLW1lc3NhZ2Vmb3JtYXQnKTtcbnJlcXVpcmUoJ3JlYWN0Jyk7XG5yZXF1aXJlKCcuL0ludGxDb250ZXh0LWI1Y2M2YmU4LmpzJyk7XG5cblxuXG5leHBvcnRzLkludGxFcnJvciA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yO1xuZXhwb3J0cy5JbnRsRXJyb3JDb2RlID0gaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlO1xuZXhwb3J0cy5pbml0aWFsaXplQ29uZmlnID0gaW5pdGlhbGl6ZUNvbmZpZy5pbml0aWFsaXplQ29uZmlnO1xuZXhwb3J0cy5jcmVhdGVUcmFuc2xhdG9yID0gY29yZS5jcmVhdGVUcmFuc2xhdG9yO1xuZXhwb3J0cy5jcmVhdGVGb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXIuY3JlYXRlRm9ybWF0dGVyO1xuZXhwb3J0cy5JbnRsUHJvdmlkZXIgPSBfSW50bFByb3ZpZGVyLkludGxQcm92aWRlcjtcbmV4cG9ydHMudXNlRm9ybWF0dGVyID0gcmVhY3QudXNlRm9ybWF0dGVyO1xuZXhwb3J0cy51c2VNZXNzYWdlcyA9IHJlYWN0LnVzZU1lc3NhZ2VzO1xuZXhwb3J0cy51c2VOb3cgPSByZWFjdC51c2VOb3c7XG5leHBvcnRzLnVzZVRpbWVab25lID0gcmVhY3QudXNlVGltZVpvbmU7XG5leHBvcnRzLnVzZVRyYW5zbGF0aW9ucyA9IHJlYWN0LnVzZVRyYW5zbGF0aW9ucztcbmV4cG9ydHMudXNlTG9jYWxlID0gX3VzZUxvY2FsZS51c2VMb2NhbGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbml0aWFsaXplQ29uZmlnIiwicmVxdWlyZSIsImNvcmUiLCJjcmVhdGVGb3JtYXR0ZXIiLCJfSW50bFByb3ZpZGVyIiwicmVhY3QiLCJfdXNlTG9jYWxlIiwiSW50bEVycm9yIiwiSW50bEVycm9yQ29kZSIsImNyZWF0ZVRyYW5zbGF0b3IiLCJJbnRsUHJvdmlkZXIiLCJ1c2VGb3JtYXR0ZXIiLCJ1c2VNZXNzYWdlcyIsInVzZU5vdyIsInVzZVRpbWVab25lIiwidXNlVHJhbnNsYXRpb25zIiwidXNlTG9jYWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/initializeConfig-c503e215.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nlet IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {\n    IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n    IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n    IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n    IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n    IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n    IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n    IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n    return IntlErrorCode;\n}({});\nclass IntlError extends Error {\n    constructor(code, originalMessage){\n        let message = code;\n        if (originalMessage) {\n            message += \": \" + originalMessage;\n        }\n        super(message);\n        _defineProperty(this, \"code\", void 0);\n        _defineProperty(this, \"originalMessage\", void 0);\n        this.code = code;\n        if (originalMessage) {\n            this.originalMessage = originalMessage;\n        }\n    }\n}\nfunction joinPath() {\n    for(var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++){\n        parts[_key] = arguments[_key];\n    }\n    return parts.filter(Boolean).join(\".\");\n}\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */ function defaultGetMessageFallback(props) {\n    return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n    console.error(error);\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n    Object.entries(messages).forEach((_ref)=>{\n        let [key, messageOrMessages] = _ref;\n        if (key.includes(\".\")) {\n            let keyLabel = key;\n            if (parentPath) keyLabel += \" (at \".concat(parentPath, \")\");\n            invalidKeyLabels.push(keyLabel);\n        }\n        if (messageOrMessages != null && typeof messageOrMessages === \"object\") {\n            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n        }\n    });\n}\nfunction validateMessages(messages, onError) {\n    const invalidKeyLabels = [];\n    validateMessagesSegment(messages, invalidKeyLabels);\n    if (invalidKeyLabels.length > 0) {\n        onError(new IntlError(IntlErrorCode.INVALID_KEY, 'Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\\n\\nInvalid '.concat(invalidKeyLabels.length === 1 ? \"key\" : \"keys\", \": \").concat(invalidKeyLabels.join(\", \"), '\\n\\nIf you\\'re migrating from a flat structure, you can convert your messages as follows:\\n\\nimport {set} from \"lodash\";\\n\\nconst input = {\\n  \"one.one\": \"1.1\",\\n  \"one.two\": \"1.2\",\\n  \"two.one.one\": \"2.1.1\"\\n};\\n\\nconst output = Object.entries(input).reduce(\\n  (acc, [key, value]) => set(acc, key, value),\\n  {}\\n);\\n\\n// Output:\\n//\\n// {\\n//   \"one\": {\\n//     \"one\": \"1.1\",\\n//     \"two\": \"1.2\"\\n//   },\\n//   \"two\": {\\n//     \"one\": {\\n//       \"one\": \"2.1.1\"\\n//     }\\n//   }\\n// }\\n')));\n    }\n}\n/**\n * Enhances the incoming props with defaults.\n */ function initializeConfig(_ref) {\n    let { getMessageFallback, messages, onError, ...rest } = _ref;\n    const finalOnError = onError || defaultOnError;\n    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n    {\n        if (messages) {\n            validateMessages(messages, finalOnError);\n        }\n    }\n    return {\n        ...rest,\n        messages,\n        onError: finalOnError,\n        getMessageFallback: finalGetMessageFallback\n    };\n}\nexports.IntlError = IntlError;\nexports.IntlErrorCode = IntlErrorCode;\nexports.defaultGetMessageFallback = defaultGetMessageFallback;\nexports.defaultOnError = defaultOnError;\nexports.initializeConfig = initializeConfig;\nexports.joinPath = joinPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbml0aWFsaXplQ29uZmlnLWM1MDNlMjE1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsU0FBU0EsZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztJQUN0Q0QsTUFBTUUsZUFBZUY7SUFDckIsSUFBSUEsT0FBT0QsS0FBSztRQUNkSSxPQUFPQyxjQUFjLENBQUNMLEtBQUtDLEtBQUs7WUFDOUJDLE9BQU9BO1lBQ1BJLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ1o7SUFDRixPQUFPO1FBQ0xSLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztJQUNiO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBLFNBQVNTLGFBQWFDLEtBQUssRUFBRUMsSUFBSTtJQUMvQixJQUFJLE9BQU9ELFVBQVUsWUFBWUEsVUFBVSxNQUFNLE9BQU9BO0lBQ3hELElBQUlFLE9BQU9GLEtBQUssQ0FBQ0csT0FBT0MsV0FBVyxDQUFDO0lBQ3BDLElBQUlGLFNBQVNHLFdBQVc7UUFDdEIsSUFBSUMsTUFBTUosS0FBS0ssSUFBSSxDQUFDUCxPQUFPQyxRQUFRO1FBQ25DLElBQUksT0FBT0ssUUFBUSxVQUFVLE9BQU9BO1FBQ3BDLE1BQU0sSUFBSUUsVUFBVTtJQUN0QjtJQUNBLE9BQU8sQ0FBQ1AsU0FBUyxXQUFXUSxTQUFTQyxNQUFLLEVBQUdWO0FBQy9DO0FBQ0EsU0FBU1AsZUFBZWtCLEdBQUc7SUFDekIsSUFBSXBCLE1BQU1RLGFBQWFZLEtBQUs7SUFDNUIsT0FBTyxPQUFPcEIsUUFBUSxXQUFXQSxNQUFNa0IsT0FBT2xCO0FBQ2hEO0FBRUEsSUFBSXFCLGdCQUFnQixXQUFXLEdBQUUsU0FBVUEsYUFBYTtJQUN0REEsYUFBYSxDQUFDLGtCQUFrQixHQUFHO0lBQ25DQSxhQUFhLENBQUMsaUJBQWlCLEdBQUc7SUFDbENBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJQUN4Q0EsYUFBYSxDQUFDLG9CQUFv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dXJjZXMiOlsid2VicGFjazovL2VuZ2xpc2gtY291cnNlcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2RldmVsb3BtZW50L2luaXRpYWxpemVDb25maWctYzUwM2UyMTUuanM/YWM0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmxldCBJbnRsRXJyb3JDb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChJbnRsRXJyb3JDb2RlKSB7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX01FU1NBR0VcIl0gPSBcIk1JU1NJTkdfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiTUlTU0lOR19GT1JNQVRcIl0gPSBcIk1JU1NJTkdfRk9STUFUXCI7XG4gIEludGxFcnJvckNvZGVbXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiXSA9IFwiRU5WSVJPTk1FTlRfRkFMTEJBQ0tcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9QQVRIXCJdID0gXCJJTlNVRkZJQ0lFTlRfUEFUSFwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9NRVNTQUdFXCJdID0gXCJJTlZBTElEX01FU1NBR0VcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOVkFMSURfS0VZXCJdID0gXCJJTlZBTElEX0tFWVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiRk9STUFUVElOR19FUlJPUlwiXSA9IFwiRk9STUFUVElOR19FUlJPUlwiO1xuICByZXR1cm4gSW50bEVycm9yQ29kZTtcbn0oe30pO1xuY2xhc3MgSW50bEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGNvZGU7XG4gICAgaWYgKG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSArPSAnOiAnICsgb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib3JpZ2luYWxNZXNzYWdlXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gam9pblBhdGgoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJ0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwYXJ0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gcGFydHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy4nKTtcbn1cblxuLyoqXG4gKiBDb250YWlucyBkZWZhdWx0cyB0aGF0IGFyZSB1c2VkIGZvciBhbGwgZW50cnkgcG9pbnRzIGludG8gdGhlIGNvcmUuXG4gKiBTZWUgYWxzbyBgSW5pdGlhbGl6ZWRJbnRsQ29uZmlndXJhdGlvbmAuXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayhwcm9wcykge1xuICByZXR1cm4gam9pblBhdGgocHJvcHMubmFtZXNwYWNlLCBwcm9wcy5rZXkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBwYXJlbnRQYXRoKSB7XG4gIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2VzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgIGxldCBba2V5LCBtZXNzYWdlT3JNZXNzYWdlc10gPSBfcmVmO1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgbGV0IGtleUxhYmVsID0ga2V5O1xuICAgICAgaWYgKHBhcmVudFBhdGgpIGtleUxhYmVsICs9IFwiIChhdCBcIi5jb25jYXQocGFyZW50UGF0aCwgXCIpXCIpO1xuICAgICAgaW52YWxpZEtleUxhYmVscy5wdXNoKGtleUxhYmVsKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VPck1lc3NhZ2VzICE9IG51bGwgJiYgdHlwZW9mIG1lc3NhZ2VPck1lc3NhZ2VzID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZU9yTWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIGpvaW5QYXRoKHBhcmVudFBhdGgsIGtleSkpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBvbkVycm9yKSB7XG4gIGNvbnN0IGludmFsaWRLZXlMYWJlbHMgPSBbXTtcbiAgdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMpO1xuICBpZiAoaW52YWxpZEtleUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuSU5WQUxJRF9LRVksIFwiTmFtZXNwYWNlIGtleXMgY2FuIG5vdCBjb250YWluIHRoZSBjaGFyYWN0ZXIgXFxcIi5cXFwiIGFzIHRoaXMgaXMgdXNlZCB0byBleHByZXNzIG5lc3RpbmcuIFBsZWFzZSByZW1vdmUgaXQgb3IgcmVwbGFjZSBpdCB3aXRoIGFub3RoZXIgY2hhcmFjdGVyLlxcblxcbkludmFsaWQgXCIuY29uY2F0KGludmFsaWRLZXlMYWJlbHMubGVuZ3RoID09PSAxID8gJ2tleScgOiAna2V5cycsIFwiOiBcIikuY29uY2F0KGludmFsaWRLZXlMYWJlbHMuam9pbignLCAnKSwgXCJcXG5cXG5JZiB5b3UncmUgbWlncmF0aW5nIGZyb20gYSBmbGF0IHN0cnVjdHVyZSwgeW91IGNhbiBjb252ZXJ0IHlvdXIgbWVzc2FnZXMgYXMgZm9sbG93czpcXG5cXG5pbXBvcnQge3NldH0gZnJvbSBcXFwibG9kYXNoXFxcIjtcXG5cXG5jb25zdCBpbnB1dCA9IHtcXG4gIFxcXCJvbmUub25lXFxcIjogXFxcIjEuMVxcXCIsXFxuICBcXFwib25lLnR3b1xcXCI6IFxcXCIxLjJcXFwiLFxcbiAgXFxcInR3by5vbmUub25lXFxcIjogXFxcIjIuMS4xXFxcIlxcbn07XFxuXFxuY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmVudHJpZXMoaW5wdXQpLnJlZHVjZShcXG4gIChhY2MsIFtrZXksIHZhbHVlXSkgPT4gc2V0KGFjYywga2V5LCB2YWx1ZSksXFxuICB7fVxcbik7XFxuXFxuLy8gT3V0cHV0Olxcbi8vXFxuLy8ge1xcbi8vICAgXFxcIm9uZVxcXCI6IHtcXG4vLyAgICAgXFxcIm9uZVxcXCI6IFxcXCIxLjFcXFwiLFxcbi8vICAgICBcXFwidHdvXFxcIjogXFxcIjEuMlxcXCJcXG4vLyAgIH0sXFxuLy8gICBcXFwidHdvXFxcIjoge1xcbi8vICAgICBcXFwib25lXFxcIjoge1xcbi8vICAgICAgIFxcXCJvbmVcXFwiOiBcXFwiMi4xLjFcXFwiXFxuLy8gICAgIH1cXG4vLyAgIH1cXG4vLyB9XFxuXCIpICkpO1xuICB9XG59XG5cbi8qKlxuICogRW5oYW5jZXMgdGhlIGluY29taW5nIHByb3BzIHdpdGggZGVmYXVsdHMuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVDb25maWcoX3JlZikge1xuICBsZXQge1xuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlcyxcbiAgICBvbkVycm9yLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGZpbmFsT25FcnJvciA9IG9uRXJyb3IgfHwgZGVmYXVsdE9uRXJyb3I7XG4gIGNvbnN0IGZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrID0gZ2V0TWVzc2FnZUZhbGxiYWNrIHx8IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2s7XG4gIHtcbiAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMsIGZpbmFsT25FcnJvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdCxcbiAgICBtZXNzYWdlcyxcbiAgICBvbkVycm9yOiBmaW5hbE9uRXJyb3IsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrOiBmaW5hbEdldE1lc3NhZ2VGYWxsYmFja1xuICB9O1xufVxuXG5leHBvcnRzLkludGxFcnJvciA9IEludGxFcnJvcjtcbmV4cG9ydHMuSW50bEVycm9yQ29kZSA9IEludGxFcnJvckNvZGU7XG5leHBvcnRzLmRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2sgPSBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrO1xuZXhwb3J0cy5kZWZhdWx0T25FcnJvciA9IGRlZmF1bHRPbkVycm9yO1xuZXhwb3J0cy5pbml0aWFsaXplQ29uZmlnID0gaW5pdGlhbGl6ZUNvbmZpZztcbmV4cG9ydHMuam9pblBhdGggPSBqb2luUGF0aDtcbiJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIl90b1Byb3BlcnR5S2V5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJpbnB1dCIsImhpbnQiLCJwcmltIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiYXJnIiwiSW50bEVycm9yQ29kZSIsIkludGxFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb2RlIiwib3JpZ2luYWxNZXNzYWdlIiwibWVzc2FnZSIsImpvaW5QYXRoIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInBhcnRzIiwiQXJyYXkiLCJfa2V5IiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwicHJvcHMiLCJuYW1lc3BhY2UiLCJkZWZhdWx0T25FcnJvciIsImVycm9yIiwiY29uc29sZSIsInZhbGlkYXRlTWVzc2FnZXNTZWdtZW50IiwibWVzc2FnZXMiLCJpbnZhbGlkS2V5TGFiZWxzIiwicGFyZW50UGF0aCIsImVudHJpZXMiLCJmb3JFYWNoIiwiX3JlZiIsIm1lc3NhZ2VPck1lc3NhZ2VzIiwiaW5jbHVkZXMiLCJrZXlMYWJlbCIsImNvbmNhdCIsInB1c2giLCJ2YWxpZGF0ZU1lc3NhZ2VzIiwib25FcnJvciIsIklOVkFMSURfS0VZIiwiaW5pdGlhbGl6ZUNvbmZpZyIsImdldE1lc3NhZ2VGYWxsYmFjayIsInJlc3QiLCJmaW5hbE9uRXJyb3IiLCJmaW5hbEdldE1lc3NhZ2VGYWxsYmFjayIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/development/react.js":
/*!*********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/react.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _IntlProvider = __webpack_require__(/*! ./_IntlProvider.js */ \"(ssr)/./node_modules/use-intl/dist/development/_IntlProvider.js\");\nvar _useLocale = __webpack_require__(/*! ./_useLocale-321e619f.js */ \"(ssr)/./node_modules/use-intl/dist/development/_useLocale-321e619f.js\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-81d7e598.js */ \"(ssr)/./node_modules/use-intl/dist/development/createFormatter-81d7e598.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(ssr)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\n__webpack_require__(/*! ./IntlContext-b5cc6be8.js */ \"(ssr)/./node_modules/use-intl/dist/development/IntlContext-b5cc6be8.js\");\n__webpack_require__(/*! intl-messageformat */ \"(ssr)/./node_modules/intl-messageformat/lib/index.js\");\nlet hasWarnedForMissingTimezone = false;\nconst isServer = \"undefined\" === \"undefined\";\nfunction useTranslationsImpl(allMessages, namespace, namespacePrefix) {\n    const { defaultTranslationValues, formats: globalFormats, getMessageFallback, locale, messageFormatCache, onError, timeZone } = _useLocale.useIntlContext();\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the hook invocation.\n    allMessages = allMessages[namespacePrefix];\n    namespace = createFormatter.resolveNamespace(namespace, namespacePrefix);\n    if (!timeZone && !hasWarnedForMissingTimezone && isServer) {\n        hasWarnedForMissingTimezone = true;\n        onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"There is no `timeZone` configured, this can lead to markup mismatches caused by environment differences. Consider adding a global default: https://next-intl-docs.vercel.app/docs/configuration#time-zone\"));\n    }\n    const translate = React.useMemo(()=>createFormatter.createBaseTranslator({\n            messageFormatCache,\n            getMessageFallback,\n            messages: allMessages,\n            defaultTranslationValues,\n            namespace,\n            onError,\n            formats: globalFormats,\n            locale,\n            timeZone\n        }), [\n        messageFormatCache,\n        getMessageFallback,\n        allMessages,\n        namespace,\n        onError,\n        defaultTranslationValues,\n        globalFormats,\n        locale,\n        timeZone\n    ]);\n    return translate;\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function useTranslations(namespace) {\n    const context = _useLocale.useIntlContext();\n    const messages = context.messages;\n    // We have to wrap the actual hook so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    return useTranslationsImpl({\n        \"!\": messages\n    }, // @ts-expect-error\n    namespace ? \"!.\".concat(namespace) : \"!\", \"!\");\n}\nfunction getNow() {\n    return new Date();\n}\n/**\n * Reading the current date via `new Date()` in components should be avoided, as\n * it causes components to be impure and can lead to flaky tests. Instead, this\n * hook can be used.\n *\n * By default, it returns the time when the component mounts. If `updateInterval`\n * is specified, the value will be updated based on the interval.\n *\n * You can however also return a static value from this hook, if you\n * configure the `now` parameter on the context provider. Note however,\n * that if `updateInterval` is configured in this case, the component\n * will initialize with the global value, but will afterwards update\n * continuously based on the interval.\n *\n * For unit tests, this can be mocked to a constant value. For end-to-end\n * testing, an environment parameter can be passed to the `now` parameter\n * of the provider to mock this to a static value.\n */ function useNow(options) {\n    const updateInterval = options === null || options === void 0 ? void 0 : options.updateInterval;\n    const { now: globalNow } = _useLocale.useIntlContext();\n    const [now, setNow] = React.useState(globalNow || getNow());\n    React.useEffect(()=>{\n        if (!updateInterval) return;\n        const intervalId = setInterval(()=>{\n            setNow(getNow());\n        }, updateInterval);\n        return ()=>{\n            clearInterval(intervalId);\n        };\n    }, [\n        globalNow,\n        updateInterval\n    ]);\n    return updateInterval == null && globalNow ? globalNow : now;\n}\nfunction useTimeZone() {\n    return _useLocale.useIntlContext().timeZone;\n}\nfunction useMessages() {\n    const context = _useLocale.useIntlContext();\n    if (!context.messages) {\n        throw new Error(\"No messages found. Have you configured them correctly? See https://next-intl-docs.vercel.app/docs/configuration#messages\");\n    }\n    return context.messages;\n}\nfunction useFormatter() {\n    const { formats, locale, now: globalNow, onError, timeZone } = _useLocale.useIntlContext();\n    return React.useMemo(()=>createFormatter.createFormatter({\n            formats,\n            locale,\n            now: globalNow,\n            onError,\n            timeZone\n        }), [\n        formats,\n        globalNow,\n        locale,\n        onError,\n        timeZone\n    ]);\n}\nexports.IntlProvider = _IntlProvider.IntlProvider;\nexports.useLocale = _useLocale.useLocale;\nexports.useFormatter = useFormatter;\nexports.useMessages = useMessages;\nexports.useNow = useNow;\nexports.useTimeZone = useTimeZone;\nexports.useTranslations = useTranslations;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9yZWFjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTztBQUFLLENBQUMsRUFBQztBQUU3RCxJQUFJQyxnQkFBZ0JDLG1CQUFPQSxDQUFDO0FBQzVCLElBQUlDLGFBQWFELG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlFLFFBQVFGLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlHLGtCQUFrQkgsbUJBQU9BLENBQUM7QUFDOUIsSUFBSUksbUJBQW1CSixtQkFBT0EsQ0FBQztBQUMvQkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixJQUFJSyw4QkFBOEI7QUFDbEMsTUFBTUMsV0FBVyxnQkFBa0I7QUFDbkMsU0FBU0Msb0JBQW9CQyxXQUFXLEVBQUVDLFNBQVMsRUFBRUMsZUFBZTtJQUNsRSxNQUFNLEVBQ0pDLHdCQUF3QixFQUN4QkMsU0FBU0MsYUFBYSxFQUN0QkMsa0JBQWtCLEVBQ2xCQyxNQUFNLEVBQ05DLGtCQUFrQixFQUNsQkMsT0FBTyxFQUNQQyxRQUFRLEVBQ1QsR0FBR2pCLFdBQVdrQixjQUFjO0lBRTdCLG9EQUFvRDtJQUNwRCwwQ0FBMEM7SUFDMUNYLGNBQWNBLFdBQVcsQ0FBQ0UsZ0JBQWdCO0lBQzFDRCxZQUFZTixnQkFBZ0JpQixnQkFBZ0IsQ0FBQ1gsV0FBV0M7SUFDeEQsSUFBSSxDQUFDUSxZQUFZLENBQUNiLCtCQUErQkMsVUFBVTtRQUN6REQsOEJBQThCO1FBQzlCWSxRQUFRLElBQUliLGlCQUFpQmlCLFNBQVMsQ0FBQ2pCLGlCQUFpQmtCLGFBQWEsQ0FBQ0Msb0JBQW9CLEVBQUU7SUFDOUY7SUFDQSxNQUFNQyxZQUFZdEIsTUFBTXVCLE9BQU8sQ0FBQyxJQUFNdEIsZ0JBQWdCdUIsb0JBQW9CLENBQUM7WUFDekVWO1lBQ0FGO1lBQ0FhLFVBQVVuQjtZQUNWRztZQUNBRjtZQUNBUTtZQUNBTCxTQUFTQztZQUNURTtZQUNBRztRQUNGLElBQUk7UUFBQ0Y7UUFBb0JGO1FBQW9CTjtRQUFhQztRQUFXUTtRQUFTTjtRQUEwQkU7UUFBZUU7UUFBUUc7S0FBUztJQUN4SSxPQUFPTTtBQUNUO0FBRUE7Ozs7Ozs7Q0FPQyxHQUNELFNBQVNJLGdCQUFnQm5CLFNBQVM7SUFDaEMsTUFBTW9CLFVBQVU1QixXQUFXa0IsY0FBYztJQUN6QyxNQUFNUSxXQUFXRSxRQUFRRixRQUFRO0lBRWpDLHlFQUF5RTtJQUN6RSw2RUFBNkU7SUFDN0UsaUNBQWlDO0lBQ2pDLE9BQU9wQixvQkFBb0I7UUFDekIsS0FBS29CO0lBQ1AsR0FDQSxtQkFBbUI7SUFDbkJsQixZQUFZLEtBQUtxQixNQUFNLENBQUNyQixhQUFhLEtBQUs7QUFDNUM7QUFFQSxTQUFTc0I7SUFDUCxPQUFPLElBQUlDO0FBQ2I7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0FpQkMsR0FDRCxTQUFTQyxPQUFPQyxPQUFPO0lBQ3JCLE1BQU1DLGlCQUFpQkQsWUFBWSxRQUFRQSxZQUFZLEtBQUssSUFBSSxLQUFLLElBQUlBLFFBQVFDLGNBQWM7SUFDL0YsTUFBTSxFQUNKQyxLQUFLQyxTQUFTLEVBQ2YsR0FBR3BDLFdBQVdrQixjQUFjO0lBQzdCLE1BQU0sQ0FBQ2lCLEtBQUtFLE9BQU8sR0FBR3BDLE1BQU1xQyxRQUFRLENBQUNGLGFBQWFOO0lBQ2xEN0IsTUFBTXNDLFNBQVMsQ0FBQztRQUNkLElBQUksQ0FBQ0wsZ0JBQWdCO1FBQ3JCLE1BQU1NLGFBQWFDLFlBQVk7WUFDN0JKLE9BQU9QO1FBQ1QsR0FBR0k7UUFDSCxPQUFPO1lBQ0xRLGNBQWNGO1FBQ2hCO0lBQ0YsR0FBRztRQUFDSjtRQUFXRjtLQUFlO0lBQzlCLE9BQU9BLGtCQUFrQixRQUFRRSxZQUFZQSxZQUFZRDtBQUMzRDtBQUVBLFNBQVNRO0lBQ1AsT0FBTzNDLFdBQVdrQixjQUFjLEdBQUdELFFBQVE7QUFDN0M7QUFFQSxTQUFTMkI7SUFDUCxNQUFNaEIsVUFBVTVCLFdBQVdrQixjQUFjO0lBQ3pDLElBQUksQ0FBQ1UsUUFBUUYsUUFBUSxFQUFFO1FBQ3JCLE1BQU0sSUFBSW1CLE1BQU07SUFDbEI7SUFDQSxPQUFPakIsUUFBUUYsUUFBUTtBQUN6QjtBQUVBLFNBQVNvQjtJQUNQLE1BQU0sRUFDSm5DLE9BQU8sRUFDUEcsTUFBTSxFQUNOcUIsS0FBS0MsU0FBUyxFQUNkcEIsT0FBTyxFQUNQQyxRQUFRLEVBQ1QsR0FBR2pCLFdBQVdrQixjQUFjO0lBQzdCLE9BQU9qQixNQUFNdUIsT0FBTyxDQUFDLElBQU10QixnQkFBZ0JBLGVBQWUsQ0FBQztZQUN6RFM7WUFDQUc7WUFDQXFCLEtBQUtDO1lBQ0xwQjtZQUNBQztRQUNGLElBQUk7UUFBQ047UUFBU3lCO1FBQVd0QjtRQUFRRTtRQUFTQztLQUFTO0FBQ3JEO0FBRUFyQixvQkFBb0IsR0FBR0UsY0FBY2lELFlBQVk7QUFDakRuRCxpQkFBaUIsR0FBR0ksV0FBV2dELFNBQVM7QUFDeENwRCxvQkFBb0IsR0FBR2tEO0FBQ3ZCbEQsbUJBQW1CLEdBQUdnRDtBQUN0QmhELGNBQWMsR0FBR29DO0FBQ2pCcEMsbUJBQW1CLEdBQUcrQztBQUN0Qi9DLHVCQUF1QixHQUFHK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmdsaXNoLWNvdXJzZXMvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9yZWFjdC5qcz8yMTc1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIF9JbnRsUHJvdmlkZXIgPSByZXF1aXJlKCcuL19JbnRsUHJvdmlkZXIuanMnKTtcbnZhciBfdXNlTG9jYWxlID0gcmVxdWlyZSgnLi9fdXNlTG9jYWxlLTMyMWU2MTlmLmpzJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vY3JlYXRlRm9ybWF0dGVyLTgxZDdlNTk4LmpzJyk7XG52YXIgaW5pdGlhbGl6ZUNvbmZpZyA9IHJlcXVpcmUoJy4vaW5pdGlhbGl6ZUNvbmZpZy1jNTAzZTIxNS5qcycpO1xucmVxdWlyZSgnLi9JbnRsQ29udGV4dC1iNWNjNmJlOC5qcycpO1xucmVxdWlyZSgnaW50bC1tZXNzYWdlZm9ybWF0Jyk7XG5cbmxldCBoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgPSBmYWxzZTtcbmNvbnN0IGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiB1c2VUcmFuc2xhdGlvbnNJbXBsKGFsbE1lc3NhZ2VzLCBuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCkge1xuICBjb25zdCB7XG4gICAgZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzLFxuICAgIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIGxvY2FsZSxcbiAgICBtZXNzYWdlRm9ybWF0Q2FjaGUsXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9ID0gX3VzZUxvY2FsZS51c2VJbnRsQ29udGV4dCgpO1xuXG4gIC8vIFRoZSBgbmFtZXNwYWNlUHJlZml4YCBpcyBwYXJ0IG9mIHRoZSB0eXBlIHN5c3RlbS5cbiAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSBob29rIGludm9jYXRpb24uXG4gIGFsbE1lc3NhZ2VzID0gYWxsTWVzc2FnZXNbbmFtZXNwYWNlUHJlZml4XTtcbiAgbmFtZXNwYWNlID0gY3JlYXRlRm9ybWF0dGVyLnJlc29sdmVOYW1lc3BhY2UobmFtZXNwYWNlLCBuYW1lc3BhY2VQcmVmaXgpO1xuICBpZiAoIXRpbWVab25lICYmICFoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgJiYgaXNTZXJ2ZXIpIHtcbiAgICBoYXNXYXJuZWRGb3JNaXNzaW5nVGltZXpvbmUgPSB0cnVlO1xuICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgXCJUaGVyZSBpcyBubyBgdGltZVpvbmVgIGNvbmZpZ3VyZWQsIHRoaXMgY2FuIGxlYWQgdG8gbWFya3VwIG1pc21hdGNoZXMgY2F1c2VkIGJ5IGVudmlyb25tZW50IGRpZmZlcmVuY2VzLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdDogaHR0cHM6Ly9uZXh0LWludGwtZG9jcy52ZXJjZWwuYXBwL2RvY3MvY29uZmlndXJhdGlvbiN0aW1lLXpvbmVcIiApKTtcbiAgfVxuICBjb25zdCB0cmFuc2xhdGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNyZWF0ZUZvcm1hdHRlci5jcmVhdGVCYXNlVHJhbnNsYXRvcih7XG4gICAgbWVzc2FnZUZvcm1hdENhY2hlLFxuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlczogYWxsTWVzc2FnZXMsXG4gICAgZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzLFxuICAgIG5hbWVzcGFjZSxcbiAgICBvbkVycm9yLFxuICAgIGZvcm1hdHM6IGdsb2JhbEZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIHRpbWVab25lXG4gIH0pLCBbbWVzc2FnZUZvcm1hdENhY2hlLCBnZXRNZXNzYWdlRmFsbGJhY2ssIGFsbE1lc3NhZ2VzLCBuYW1lc3BhY2UsIG9uRXJyb3IsIGRlZmF1bHRUcmFuc2xhdGlvblZhbHVlcywgZ2xvYmFsRm9ybWF0cywgbG9jYWxlLCB0aW1lWm9uZV0pO1xuICByZXR1cm4gdHJhbnNsYXRlO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gdXNlVHJhbnNsYXRpb25zKG5hbWVzcGFjZSkge1xuICBjb25zdCBjb250ZXh0ID0gX3VzZUxvY2FsZS51c2VJbnRsQ29udGV4dCgpO1xuICBjb25zdCBtZXNzYWdlcyA9IGNvbnRleHQubWVzc2FnZXM7XG5cbiAgLy8gV2UgaGF2ZSB0byB3cmFwIHRoZSBhY3R1YWwgaG9vayBzbyB0aGUgdHlwZSBpbmZlcmVuY2UgZm9yIHRoZSBvcHRpb25hbFxuICAvLyBuYW1lc3BhY2Ugd29ya3MgY29ycmVjdGx5LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICAvLyBUaGUgcHJlZml4IChcIiFcIikgaXMgYXJiaXRyYXJ5LlxuICByZXR1cm4gdXNlVHJhbnNsYXRpb25zSW1wbCh7XG4gICAgJyEnOiBtZXNzYWdlc1xuICB9LFxuICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gIG5hbWVzcGFjZSA/IFwiIS5cIi5jb25jYXQobmFtZXNwYWNlKSA6ICchJywgJyEnKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm93KCkge1xuICByZXR1cm4gbmV3IERhdGUoKTtcbn1cblxuLyoqXG4gKiBSZWFkaW5nIHRoZSBjdXJyZW50IGRhdGUgdmlhIGBuZXcgRGF0ZSgpYCBpbiBjb21wb25lbnRzIHNob3VsZCBiZSBhdm9pZGVkLCBhc1xuICogaXQgY2F1c2VzIGNvbXBvbmVudHMgdG8gYmUgaW1wdXJlIGFuZCBjYW4gbGVhZCB0byBmbGFreSB0ZXN0cy4gSW5zdGVhZCwgdGhpc1xuICogaG9vayBjYW4gYmUgdXNlZC5cbiAqXG4gKiBCeSBkZWZhdWx0LCBpdCByZXR1cm5zIHRoZSB0aW1lIHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHMuIElmIGB1cGRhdGVJbnRlcnZhbGBcbiAqIGlzIHNwZWNpZmllZCwgdGhlIHZhbHVlIHdpbGwgYmUgdXBkYXRlZCBiYXNlZCBvbiB0aGUgaW50ZXJ2YWwuXG4gKlxuICogWW91IGNhbiBob3dldmVyIGFsc28gcmV0dXJuIGEgc3RhdGljIHZhbHVlIGZyb20gdGhpcyBob29rLCBpZiB5b3VcbiAqIGNvbmZpZ3VyZSB0aGUgYG5vd2AgcGFyYW1ldGVyIG9uIHRoZSBjb250ZXh0IHByb3ZpZGVyLiBOb3RlIGhvd2V2ZXIsXG4gKiB0aGF0IGlmIGB1cGRhdGVJbnRlcnZhbGAgaXMgY29uZmlndXJlZCBpbiB0aGlzIGNhc2UsIHRoZSBjb21wb25lbnRcbiAqIHdpbGwgaW5pdGlhbGl6ZSB3aXRoIHRoZSBnbG9iYWwgdmFsdWUsIGJ1dCB3aWxsIGFmdGVyd2FyZHMgdXBkYXRlXG4gKiBjb250aW51b3VzbHkgYmFzZWQgb24gdGhlIGludGVydmFsLlxuICpcbiAqIEZvciB1bml0IHRlc3RzLCB0aGlzIGNhbiBiZSBtb2NrZWQgdG8gYSBjb25zdGFudCB2YWx1ZS4gRm9yIGVuZC10by1lbmRcbiAqIHRlc3RpbmcsIGFuIGVudmlyb25tZW50IHBhcmFtZXRlciBjYW4gYmUgcGFzc2VkIHRvIHRoZSBgbm93YCBwYXJhbWV0ZXJcbiAqIG9mIHRoZSBwcm92aWRlciB0byBtb2NrIHRoaXMgdG8gYSBzdGF0aWMgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHVzZU5vdyhvcHRpb25zKSB7XG4gIGNvbnN0IHVwZGF0ZUludGVydmFsID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVwZGF0ZUludGVydmFsO1xuICBjb25zdCB7XG4gICAgbm93OiBnbG9iYWxOb3dcbiAgfSA9IF91c2VMb2NhbGUudXNlSW50bENvbnRleHQoKTtcbiAgY29uc3QgW25vdywgc2V0Tm93XSA9IFJlYWN0LnVzZVN0YXRlKGdsb2JhbE5vdyB8fCBnZXROb3coKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCF1cGRhdGVJbnRlcnZhbCkgcmV0dXJuO1xuICAgIGNvbnN0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBzZXROb3coZ2V0Tm93KCkpO1xuICAgIH0sIHVwZGF0ZUludGVydmFsKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbElkKTtcbiAgICB9O1xuICB9LCBbZ2xvYmFsTm93LCB1cGRhdGVJbnRlcnZhbF0pO1xuICByZXR1cm4gdXBkYXRlSW50ZXJ2YWwgPT0gbnVsbCAmJiBnbG9iYWxOb3cgPyBnbG9iYWxOb3cgOiBub3c7XG59XG5cbmZ1bmN0aW9uIHVzZVRpbWVab25lKCkge1xuICByZXR1cm4gX3VzZUxvY2FsZS51c2VJbnRsQ29udGV4dCgpLnRpbWVab25lO1xufVxuXG5mdW5jdGlvbiB1c2VNZXNzYWdlcygpIHtcbiAgY29uc3QgY29udGV4dCA9IF91c2VMb2NhbGUudXNlSW50bENvbnRleHQoKTtcbiAgaWYgKCFjb250ZXh0Lm1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBtZXNzYWdlcyBmb3VuZC4gSGF2ZSB5b3UgY29uZmlndXJlZCB0aGVtIGNvcnJlY3RseT8gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL2NvbmZpZ3VyYXRpb24jbWVzc2FnZXMnICk7XG4gIH1cbiAgcmV0dXJuIGNvbnRleHQubWVzc2FnZXM7XG59XG5cbmZ1bmN0aW9uIHVzZUZvcm1hdHRlcigpIHtcbiAgY29uc3Qge1xuICAgIGZvcm1hdHMsXG4gICAgbG9jYWxlLFxuICAgIG5vdzogZ2xvYmFsTm93LFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmVcbiAgfSA9IF91c2VMb2NhbGUudXNlSW50bENvbnRleHQoKTtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gY3JlYXRlRm9ybWF0dGVyLmNyZWF0ZUZvcm1hdHRlcih7XG4gICAgZm9ybWF0cyxcbiAgICBsb2NhbGUsXG4gICAgbm93OiBnbG9iYWxOb3csXG4gICAgb25FcnJvcixcbiAgICB0aW1lWm9uZVxuICB9KSwgW2Zvcm1hdHMsIGdsb2JhbE5vdywgbG9jYWxlLCBvbkVycm9yLCB0aW1lWm9uZV0pO1xufVxuXG5leHBvcnRzLkludGxQcm92aWRlciA9IF9JbnRsUHJvdmlkZXIuSW50bFByb3ZpZGVyO1xuZXhwb3J0cy51c2VMb2NhbGUgPSBfdXNlTG9jYWxlLnVzZUxvY2FsZTtcbmV4cG9ydHMudXNlRm9ybWF0dGVyID0gdXNlRm9ybWF0dGVyO1xuZXhwb3J0cy51c2VNZXNzYWdlcyA9IHVzZU1lc3NhZ2VzO1xuZXhwb3J0cy51c2VOb3cgPSB1c2VOb3c7XG5leHBvcnRzLnVzZVRpbWVab25lID0gdXNlVGltZVpvbmU7XG5leHBvcnRzLnVzZVRyYW5zbGF0aW9ucyA9IHVzZVRyYW5zbGF0aW9ucztcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsIl9JbnRsUHJvdmlkZXIiLCJyZXF1aXJlIiwiX3VzZUxvY2FsZSIsIlJlYWN0IiwiY3JlYXRlRm9ybWF0dGVyIiwiaW5pdGlhbGl6ZUNvbmZpZyIsImhhc1dhcm5lZEZvck1pc3NpbmdUaW1lem9uZSIsImlzU2VydmVyIiwidXNlVHJhbnNsYXRpb25zSW1wbCIsImFsbE1lc3NhZ2VzIiwibmFtZXNwYWNlIiwibmFtZXNwYWNlUHJlZml4IiwiZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzIiwiZm9ybWF0cyIsImdsb2JhbEZvcm1hdHMiLCJnZXRNZXNzYWdlRmFsbGJhY2siLCJsb2NhbGUiLCJtZXNzYWdlRm9ybWF0Q2FjaGUiLCJvbkVycm9yIiwidGltZVpvbmUiLCJ1c2VJbnRsQ29udGV4dCIsInJlc29sdmVOYW1lc3BhY2UiLCJJbnRsRXJyb3IiLCJJbnRsRXJyb3JDb2RlIiwiRU5WSVJPTk1FTlRfRkFMTEJBQ0siLCJ0cmFuc2xhdGUiLCJ1c2VNZW1vIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3IiLCJtZXNzYWdlcyIsInVzZVRyYW5zbGF0aW9ucyIsImNvbnRleHQiLCJjb25jYXQiLCJnZXROb3ciLCJEYXRlIiwidXNlTm93Iiwib3B0aW9ucyIsInVwZGF0ZUludGVydmFsIiwibm93IiwiZ2xvYmFsTm93Iiwic2V0Tm93IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJjbGVhckludGVydmFsIiwidXNlVGltZVpvbmUiLCJ1c2VNZXNzYWdlcyIsIkVycm9yIiwidXNlRm9ybWF0dGVyIiwiSW50bFByb3ZpZGVyIiwidXNlTG9jYWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/development/react.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/use-intl/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/use-intl/dist/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./development/index.js */ \"(ssr)/./node_modules/use-intl/dist/development/index.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUlBLEtBQXlCLEVBQWMsRUFFMUMsTUFBTTtJQUNMQyw2SEFBeUI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmdsaXNoLWNvdXJzZXMvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9pbmRleC5qcz83YjExIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3Byb2R1Y3Rpb24vaW5kZXguanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZXZlbG9wbWVudC9pbmRleC5qcycpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwicmVxdWlyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/use-intl/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/use-intl/dist/development/core.js":
/*!********************************************************!*\
  !*** ./node_modules/use-intl/dist/development/core.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(rsc)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nvar createFormatter = __webpack_require__(/*! ./createFormatter-81d7e598.js */ \"(rsc)/./node_modules/use-intl/dist/development/createFormatter-81d7e598.js\");\n__webpack_require__(/*! intl-messageformat */ \"(rsc)/./node_modules/intl-messageformat/lib/index.js\");\n__webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\nfunction createTranslatorImpl(_ref, namespacePrefix) {\n    let { getMessageFallback, messages, namespace, onError, ...rest } = _ref;\n    // The `namespacePrefix` is part of the type system.\n    // See the comment in the function invocation.\n    messages = messages[namespacePrefix];\n    namespace = createFormatter.resolveNamespace(namespace, namespacePrefix);\n    return createFormatter.createBaseTranslator({\n        ...rest,\n        onError,\n        getMessageFallback,\n        messages,\n        namespace\n    });\n}\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */ function createTranslator(_ref) {\n    let { getMessageFallback = initializeConfig.defaultGetMessageFallback, messages, namespace, onError = initializeConfig.defaultOnError, ...rest } = _ref;\n    // We have to wrap the actual function so the type inference for the optional\n    // namespace works correctly. See https://stackoverflow.com/a/71529575/343045\n    // The prefix (\"!\") is arbitrary.\n    return createTranslatorImpl({\n        ...rest,\n        onError,\n        getMessageFallback,\n        // @ts-expect-error `messages` is allowed to be `undefined` here and will be handled internally\n        messages: {\n            \"!\": messages\n        },\n        namespace: namespace ? \"!.\".concat(namespace) : \"!\"\n    }, \"!\");\n}\nexports.IntlError = initializeConfig.IntlError;\nexports.IntlErrorCode = initializeConfig.IntlErrorCode;\nexports.initializeConfig = initializeConfig.initializeConfig;\nexports.createFormatter = createFormatter.createFormatter;\nexports.createTranslator = createTranslator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBRTdELElBQUlDLG1CQUFtQkMsbUJBQU9BLENBQUM7QUFDL0IsSUFBSUMsa0JBQWtCRCxtQkFBT0EsQ0FBQztBQUM5QkEsbUJBQU9BLENBQUM7QUFDUkEsbUJBQU9BLENBQUM7QUFFUixTQUFTRSxxQkFBcUJDLElBQUksRUFBRUMsZUFBZTtJQUNqRCxJQUFJLEVBQ0ZDLGtCQUFrQixFQUNsQkMsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLE9BQU8sRUFDUCxHQUFHQyxNQUNKLEdBQUdOO0lBQ0osb0RBQW9EO0lBQ3BELDhDQUE4QztJQUM5Q0csV0FBV0EsUUFBUSxDQUFDRixnQkFBZ0I7SUFDcENHLFlBQVlOLGdCQUFnQlMsZ0JBQWdCLENBQUNILFdBQVdIO0lBQ3hELE9BQU9ILGdCQUFnQlUsb0JBQW9CLENBQUM7UUFDMUMsR0FBR0YsSUFBSTtRQUNQRDtRQUNBSDtRQUNBQztRQUNBQztJQUNGO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0ssaUJBQWlCVCxJQUFJO0lBQzVCLElBQUksRUFDRkUscUJBQXFCTixpQkFBaUJjLHlCQUF5QixFQUMvRFAsUUFBUSxFQUNSQyxTQUFTLEVBQ1RDLFVBQVVULGlCQUFpQmUsY0FBYyxFQUN6QyxHQUFHTCxNQUNKLEdBQUdOO0lBQ0osNkVBQTZFO0lBQzdFLDZFQUE2RTtJQUM3RSxpQ0FBaUM7SUFDakMsT0FBT0QscUJBQXFCO1FBQzFCLEdBQUdPLElBQUk7UUFDUEQ7UUFDQUg7UUFDQSwrRkFBK0Y7UUFDL0ZDLFVBQVU7WUFDUixLQUFLQTtRQUNQO1FBQ0FDLFdBQVdBLFlBQVksS0FBS1EsTUFBTSxDQUFDUixhQUFhO0lBQ2xELEdBQUc7QUFDTDtBQUVBVixpQkFBaUIsR0FBR0UsaUJBQWlCaUIsU0FBUztBQUM5Q25CLHFCQUFxQixHQUFHRSxpQkFBaUJrQixhQUFhO0FBQ3REcEIsd0JBQXdCLEdBQUdFLGlCQUFpQkEsZ0JBQWdCO0FBQzVERix1QkFBdUIsR0FBR0ksZ0JBQWdCQSxlQUFlO0FBQ3pESix3QkFBd0IsR0FBR2UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmdsaXNoLWNvdXJzZXMvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jb3JlLmpzP2RiODYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgaW5pdGlhbGl6ZUNvbmZpZyA9IHJlcXVpcmUoJy4vaW5pdGlhbGl6ZUNvbmZpZy1jNTAzZTIxNS5qcycpO1xudmFyIGNyZWF0ZUZvcm1hdHRlciA9IHJlcXVpcmUoJy4vY3JlYXRlRm9ybWF0dGVyLTgxZDdlNTk4LmpzJyk7XG5yZXF1aXJlKCdpbnRsLW1lc3NhZ2Vmb3JtYXQnKTtcbnJlcXVpcmUoJ3JlYWN0Jyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zbGF0b3JJbXBsKF9yZWYsIG5hbWVzcGFjZVByZWZpeCkge1xuICBsZXQge1xuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlcyxcbiAgICBuYW1lc3BhY2UsXG4gICAgb25FcnJvcixcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICAvLyBUaGUgYG5hbWVzcGFjZVByZWZpeGAgaXMgcGFydCBvZiB0aGUgdHlwZSBzeXN0ZW0uXG4gIC8vIFNlZSB0aGUgY29tbWVudCBpbiB0aGUgZnVuY3Rpb24gaW52b2NhdGlvbi5cbiAgbWVzc2FnZXMgPSBtZXNzYWdlc1tuYW1lc3BhY2VQcmVmaXhdO1xuICBuYW1lc3BhY2UgPSBjcmVhdGVGb3JtYXR0ZXIucmVzb2x2ZU5hbWVzcGFjZShuYW1lc3BhY2UsIG5hbWVzcGFjZVByZWZpeCk7XG4gIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIuY3JlYXRlQmFzZVRyYW5zbGF0b3Ioe1xuICAgIC4uLnJlc3QsXG4gICAgb25FcnJvcixcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbWVzc2FnZXMsXG4gICAgbmFtZXNwYWNlXG4gIH0pO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZXMgbWVzc2FnZXMgZnJvbSB0aGUgZ2l2ZW4gbmFtZXNwYWNlIGJ5IHVzaW5nIHRoZSBJQ1Ugc3ludGF4LlxuICogU2VlIGh0dHBzOi8vZm9ybWF0anMuaW8vZG9jcy9jb3JlLWNvbmNlcHRzL2ljdS1zeW50YXguXG4gKlxuICogSWYgbm8gbmFtZXNwYWNlIGlzIHByb3ZpZGVkLCBhbGwgYXZhaWxhYmxlIG1lc3NhZ2VzIGFyZSByZXR1cm5lZC5cbiAqIFRoZSBuYW1lc3BhY2UgY2FuIGFsc28gaW5kaWNhdGUgbmVzdGluZyBieSB1c2luZyBhIGRvdFxuICogKGUuZy4gYG5hbWVzcGFjZS5Db21wb25lbnRgKS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJhbnNsYXRvcihfcmVmKSB7XG4gIGxldCB7XG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrID0gaW5pdGlhbGl6ZUNvbmZpZy5kZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrLFxuICAgIG1lc3NhZ2VzLFxuICAgIG5hbWVzcGFjZSxcbiAgICBvbkVycm9yID0gaW5pdGlhbGl6ZUNvbmZpZy5kZWZhdWx0T25FcnJvcixcbiAgICAuLi5yZXN0XG4gIH0gPSBfcmVmO1xuICAvLyBXZSBoYXZlIHRvIHdyYXAgdGhlIGFjdHVhbCBmdW5jdGlvbiBzbyB0aGUgdHlwZSBpbmZlcmVuY2UgZm9yIHRoZSBvcHRpb25hbFxuICAvLyBuYW1lc3BhY2Ugd29ya3MgY29ycmVjdGx5LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICAvLyBUaGUgcHJlZml4IChcIiFcIikgaXMgYXJiaXRyYXJ5LlxuICByZXR1cm4gY3JlYXRlVHJhbnNsYXRvckltcGwoe1xuICAgIC4uLnJlc3QsXG4gICAgb25FcnJvcixcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBgbWVzc2FnZXNgIGlzIGFsbG93ZWQgdG8gYmUgYHVuZGVmaW5lZGAgaGVyZSBhbmQgd2lsbCBiZSBoYW5kbGVkIGludGVybmFsbHlcbiAgICBtZXNzYWdlczoge1xuICAgICAgJyEnOiBtZXNzYWdlc1xuICAgIH0sXG4gICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UgPyBcIiEuXCIuY29uY2F0KG5hbWVzcGFjZSkgOiAnISdcbiAgfSwgJyEnKTtcbn1cblxuZXhwb3J0cy5JbnRsRXJyb3IgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcjtcbmV4cG9ydHMuSW50bEVycm9yQ29kZSA9IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZTtcbmV4cG9ydHMuaW5pdGlhbGl6ZUNvbmZpZyA9IGluaXRpYWxpemVDb25maWcuaW5pdGlhbGl6ZUNvbmZpZztcbmV4cG9ydHMuY3JlYXRlRm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyLmNyZWF0ZUZvcm1hdHRlcjtcbmV4cG9ydHMuY3JlYXRlVHJhbnNsYXRvciA9IGNyZWF0ZVRyYW5zbGF0b3I7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJpbml0aWFsaXplQ29uZmlnIiwicmVxdWlyZSIsImNyZWF0ZUZvcm1hdHRlciIsImNyZWF0ZVRyYW5zbGF0b3JJbXBsIiwiX3JlZiIsIm5hbWVzcGFjZVByZWZpeCIsImdldE1lc3NhZ2VGYWxsYmFjayIsIm1lc3NhZ2VzIiwibmFtZXNwYWNlIiwib25FcnJvciIsInJlc3QiLCJyZXNvbHZlTmFtZXNwYWNlIiwiY3JlYXRlQmFzZVRyYW5zbGF0b3IiLCJjcmVhdGVUcmFuc2xhdG9yIiwiZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayIsImRlZmF1bHRPbkVycm9yIiwiY29uY2F0IiwiSW50bEVycm9yIiwiSW50bEVycm9yQ29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/use-intl/dist/development/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/use-intl/dist/development/createFormatter-81d7e598.js":
/*!****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/createFormatter-81d7e598.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar IntlMessageFormat = __webpack_require__(/*! intl-messageformat */ \"(rsc)/./node_modules/intl-messageformat/lib/index.js\");\nvar React = __webpack_require__(/*! react */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/rsc/react.js\");\nvar initializeConfig = __webpack_require__(/*! ./initializeConfig-c503e215.js */ \"(rsc)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar IntlMessageFormat__default = /*#__PURE__*/ _interopDefault(IntlMessageFormat);\n// eslint-disable-next-line import/no-named-as-default -- False positive\nfunction setTimeZoneInFormats(formats, timeZone) {\n    if (!formats) return formats;\n    // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n    // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n    return Object.keys(formats).reduce((acc, key)=>{\n        acc[key] = {\n            timeZone,\n            ...formats[key]\n        };\n        return acc;\n    }, {});\n}\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */ function convertFormatsToIntlMessageFormat(formats, timeZone) {\n    const formatsWithTimeZone = timeZone ? {\n        ...formats,\n        dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)\n    } : formats;\n    const mfDateDefaults = IntlMessageFormat__default.default.formats.date;\n    const defaultDateFormats = timeZone ? setTimeZoneInFormats(mfDateDefaults, timeZone) : mfDateDefaults;\n    const mfTimeDefaults = IntlMessageFormat__default.default.formats.time;\n    const defaultTimeFormats = timeZone ? setTimeZoneInFormats(mfTimeDefaults, timeZone) : mfTimeDefaults;\n    return {\n        ...formatsWithTimeZone,\n        date: {\n            ...defaultDateFormats,\n            ...formatsWithTimeZone === null || formatsWithTimeZone === void 0 ? void 0 : formatsWithTimeZone.dateTime\n        },\n        time: {\n            ...defaultTimeFormats,\n            ...formatsWithTimeZone === null || formatsWithTimeZone === void 0 ? void 0 : formatsWithTimeZone.dateTime\n        }\n    };\n}\n// eslint-disable-next-line import/no-named-as-default -- False positive\nfunction resolvePath(locale, messages, key, namespace) {\n    const fullKey = initializeConfig.joinPath(namespace, key);\n    if (!messages) {\n        throw new Error(\"No messages available at `\".concat(namespace, \"`.\"));\n    }\n    let message = messages;\n    key.split(\".\").forEach((part)=>{\n        const next = message[part];\n        if (part == null || next == null) {\n            throw new Error(\"Could not resolve `\".concat(fullKey, \"` in messages for locale `\").concat(locale, \"`.\"));\n        }\n        message = next;\n    });\n    return message;\n}\nfunction prepareTranslationValues(values) {\n    if (Object.keys(values).length === 0) return undefined;\n    // Workaround for https://github.com/formatjs/formatjs/issues/1467\n    const transformedValues = {};\n    Object.keys(values).forEach((key)=>{\n        let index = 0;\n        const value = values[key];\n        let transformed;\n        if (typeof value === \"function\") {\n            transformed = (chunks)=>{\n                const result = value(chunks);\n                return /*#__PURE__*/ React.isValidElement(result) ? /*#__PURE__*/ React.cloneElement(result, {\n                    key: key + index++\n                }) : result;\n            };\n        } else {\n            transformed = value;\n        }\n        transformedValues[key] = transformed;\n    });\n    return transformedValues;\n}\nfunction getMessagesOrError(locale, messages, namespace) {\n    let onError = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : initializeConfig.defaultOnError;\n    try {\n        if (!messages) {\n            throw new Error(\"No messages were configured on the provider.\");\n        }\n        const retrievedMessages = namespace ? resolvePath(locale, messages, namespace) : messages;\n        if (!retrievedMessages) {\n            throw new Error(\"No messages for namespace `\".concat(namespace, \"` found.\"));\n        }\n        return retrievedMessages;\n    } catch (error) {\n        const intlError = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        onError(intlError);\n        return intlError;\n    }\n}\nfunction getPlainMessage(candidate, values) {\n    if (values) return undefined;\n    const unescapedMessage = candidate.replace(/'([{}])/gi, \"$1\");\n    // Placeholders can be in the message if there are default values,\n    // or if the user has forgotten to provide values. In the latter\n    // case we need to compile the message to receive an error.\n    const hasPlaceholders = /<|{/.test(unescapedMessage);\n    if (!hasPlaceholders) {\n        return unescapedMessage;\n    }\n    return undefined;\n}\nfunction createBaseTranslator(config) {\n    const messagesOrError = getMessagesOrError(config.locale, config.messages, config.namespace, config.onError);\n    return createBaseTranslatorImpl({\n        ...config,\n        messagesOrError\n    });\n}\nfunction createBaseTranslatorImpl(_ref) {\n    let { defaultTranslationValues, formats: globalFormats, getMessageFallback = initializeConfig.defaultGetMessageFallback, locale, messageFormatCache, messagesOrError, namespace, onError, timeZone } = _ref;\n    function getFallbackFromErrorAndNotify(key, code, message) {\n        const error = new initializeConfig.IntlError(code, message);\n        onError(error);\n        return getMessageFallback({\n            error,\n            key,\n            namespace\n        });\n    }\n    function translateBaseFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        if (messagesOrError instanceof initializeConfig.IntlError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        let message;\n        try {\n            message = resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n        const cacheKey = initializeConfig.joinPath(locale, namespace, key, String(message));\n        let messageFormat;\n        if (messageFormatCache !== null && messageFormatCache !== void 0 && messageFormatCache.has(cacheKey)) {\n            messageFormat = messageFormatCache.get(cacheKey);\n        } else {\n            if (typeof message === \"object\") {\n                let code, errorMessage;\n                if (Array.isArray(message)) {\n                    code = initializeConfig.IntlErrorCode.INVALID_MESSAGE;\n                    {\n                        errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an array, but only strings are supported. See https://next-intl-docs.vercel.app/docs/usage/messages#arrays-of-messages\");\n                    }\n                } else {\n                    code = initializeConfig.IntlErrorCode.INSUFFICIENT_PATH;\n                    {\n                        errorMessage = \"Message at `\".concat(initializeConfig.joinPath(namespace, key), \"` resolved to an object, but only strings are supported. Use a `.` to retrieve nested messages. See https://next-intl-docs.vercel.app/docs/usage/messages#structuring-messages\");\n                    }\n                }\n                return getFallbackFromErrorAndNotify(key, code, errorMessage);\n            }\n            // Hot path that avoids creating an `IntlMessageFormat` instance\n            const plainMessage = getPlainMessage(message, values);\n            if (plainMessage) return plainMessage;\n            try {\n                messageFormat = new IntlMessageFormat__default.default(message, locale, convertFormatsToIntlMessageFormat({\n                    ...globalFormats,\n                    ...formats\n                }, timeZone), {\n                    formatters: {\n                        getNumberFormat (locales, options) {\n                            return new Intl.NumberFormat(locales, options);\n                        },\n                        getDateTimeFormat (locales, options) {\n                            // Workaround for https://github.com/formatjs/formatjs/issues/4279\n                            return new Intl.DateTimeFormat(locales, {\n                                timeZone,\n                                ...options\n                            });\n                        },\n                        getPluralRules (locales, options) {\n                            return new Intl.PluralRules(locales, options);\n                        }\n                    }\n                });\n            } catch (error) {\n                const thrownError = error;\n                return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, thrownError.message + (\"originalMessage\" in thrownError ? \" (\".concat(thrownError.originalMessage, \")\") : \"\"));\n            }\n            messageFormatCache === null || messageFormatCache === void 0 || messageFormatCache.set(cacheKey, messageFormat);\n        }\n        try {\n            const formattedMessage = messageFormat.format(// @ts-expect-error `intl-messageformat` expects a different format\n            // for rich text elements since a recent minor update. This\n            // needs to be evaluated in detail, possibly also in regards\n            // to be able to format to parts.\n            prepareTranslationValues({\n                ...defaultTranslationValues,\n                ...values\n            }));\n            if (formattedMessage == null) {\n                throw new Error(\"Unable to format `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\"));\n            }\n            // Limit the function signature to return strings or React elements\n            return /*#__PURE__*/ React.isValidElement(formattedMessage) || // Arrays of React elements\n            Array.isArray(formattedMessage) || typeof formattedMessage === \"string\" ? formattedMessage : String(formattedMessage);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message);\n        }\n    }\n    function translateFn(/** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */ key, /** Key value pairs for values to interpolate into the message. */ values, /** Provide custom formats for numbers, dates and times. */ formats) {\n        const result = translateBaseFn(key, values, formats);\n        if (typeof result !== \"string\") {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.INVALID_MESSAGE, \"The message `\".concat(key, \"` in \").concat(namespace ? \"namespace `\".concat(namespace, \"`\") : \"messages\", \" didn't resolve to a string. If you want to format rich text, use `t.rich` instead.\"));\n        }\n        return result;\n    }\n    translateFn.rich = translateBaseFn;\n    // Augment `translateBaseFn` to return plain strings\n    translateFn.markup = (key, values, formats)=>{\n        const result = translateBaseFn(key, // @ts-expect-error -- `MarkupTranslationValues` is practically a sub type\n        // of `RichTranslationValues` but TypeScript isn't smart enough here.\n        values, formats);\n        // When only string chunks are provided to the parser, only\n        // strings should be returned here. Note that we need a runtime\n        // check for this since rich text values could be accidentally\n        // inherited from `defaultTranslationValues`.\n        if (typeof result !== \"string\") {\n            const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, \"`t.markup` only accepts functions for formatting that receive and return strings.\\n\\nE.g. t.markup('markup', {b: (chunks) => `<b>${chunks}</b>`})\");\n            onError(error);\n            return getMessageFallback({\n                error,\n                key,\n                namespace\n            });\n        }\n        return result;\n    };\n    translateFn.raw = (key)=>{\n        if (messagesOrError instanceof initializeConfig.IntlError) {\n            // We have already warned about this during render\n            return getMessageFallback({\n                error: messagesOrError,\n                key,\n                namespace\n            });\n        }\n        const messages = messagesOrError;\n        try {\n            return resolvePath(locale, messages, key, namespace);\n        } catch (error) {\n            return getFallbackFromErrorAndNotify(key, initializeConfig.IntlErrorCode.MISSING_MESSAGE, error.message);\n        }\n    };\n    return translateFn;\n}\n/**\n * For the strictly typed messages to work we have to wrap the namespace into\n * a mandatory prefix. See https://stackoverflow.com/a/71529575/343045\n */ function resolveNamespace(namespace, namespacePrefix) {\n    return namespace === namespacePrefix ? undefined : namespace.slice((namespacePrefix + \".\").length);\n}\nconst SECOND = 1;\nconst MINUTE = SECOND * 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst QUARTER = MONTH * 3;\nconst YEAR = DAY * 365;\nconst UNIT_SECONDS = {\n    second: SECOND,\n    seconds: SECOND,\n    minute: MINUTE,\n    minutes: MINUTE,\n    hour: HOUR,\n    hours: HOUR,\n    day: DAY,\n    days: DAY,\n    week: WEEK,\n    weeks: WEEK,\n    month: MONTH,\n    months: MONTH,\n    quarter: QUARTER,\n    quarters: QUARTER,\n    year: YEAR,\n    years: YEAR\n};\nfunction resolveRelativeTimeUnit(seconds) {\n    const absValue = Math.abs(seconds);\n    if (absValue < MINUTE) {\n        return \"second\";\n    } else if (absValue < HOUR) {\n        return \"minute\";\n    } else if (absValue < DAY) {\n        return \"hour\";\n    } else if (absValue < WEEK) {\n        return \"day\";\n    } else if (absValue < MONTH) {\n        return \"week\";\n    } else if (absValue < YEAR) {\n        return \"month\";\n    }\n    return \"year\";\n}\nfunction calculateRelativeTimeValue(seconds, unit) {\n    // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n    // will include fractions like '2.1 hours ago'.\n    return Math.round(seconds / UNIT_SECONDS[unit]);\n}\nfunction createFormatter(_ref) {\n    let { formats, locale, now: globalNow, onError = initializeConfig.defaultOnError, timeZone: globalTimeZone } = _ref;\n    function applyTimeZone(options) {\n        var _options;\n        if (!((_options = options) !== null && _options !== void 0 && _options.timeZone)) {\n            if (globalTimeZone) {\n                options = {\n                    ...options,\n                    timeZone: globalTimeZone\n                };\n            } else {\n                onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `timeZone` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#time-zone\"));\n            }\n        }\n        return options;\n    }\n    function resolveFormatOrOptions(typeFormats, formatOrOptions) {\n        let options;\n        if (typeof formatOrOptions === \"string\") {\n            const formatName = formatOrOptions;\n            options = typeFormats === null || typeFormats === void 0 ? void 0 : typeFormats[formatName];\n            if (!options) {\n                const error = new initializeConfig.IntlError(initializeConfig.IntlErrorCode.MISSING_FORMAT, \"Format `\".concat(formatName, \"` is not available. You can configure it on the provider or provide custom options.\"));\n                onError(error);\n                throw error;\n            }\n        } else {\n            options = formatOrOptions;\n        }\n        return options;\n    }\n    function getFormattedValue(formatOrOptions, typeFormats, formatter, getFallback) {\n        let options;\n        try {\n            options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n        } catch (error) {\n            return getFallback();\n        }\n        try {\n            return formatter(options);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return getFallback();\n        }\n    }\n    function dateTime(/** If a number is supplied, this is interpreted as a UTC timestamp. */ value, /** If a time zone is supplied, the `value` is converted to that time zone.\n   * Otherwise the user time zone will be used. */ formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return new Intl.DateTimeFormat(locale, options).format(value);\n        }, ()=>String(value));\n    }\n    function dateTimeRange(/** If a number is supplied, this is interpreted as a UTC timestamp. */ start, /** If a number is supplied, this is interpreted as a UTC timestamp. */ end, /** If a time zone is supplied, the values are converted to that time zone.\n   * Otherwise the user time zone will be used. */ formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.dateTime, (options)=>{\n            options = applyTimeZone(options);\n            return new Intl.DateTimeFormat(locale, options).formatRange(start, end);\n        }, ()=>[\n                dateTime(start),\n                dateTime(end)\n            ].join(\" – \"));\n    }\n    function number(value, formatOrOptions) {\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.number, (options)=>new Intl.NumberFormat(locale, options).format(value), ()=>String(value));\n    }\n    function getGlobalNow() {\n        if (globalNow) {\n            return globalNow;\n        } else {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.ENVIRONMENT_FALLBACK, \"The `now` parameter wasn't provided and there is no global default configured. Consider adding a global default to avoid markup mismatches caused by environment differences. Learn more: https://next-intl-docs.vercel.app/docs/configuration#now\"));\n            return new Date();\n        }\n    }\n    function extractNowDate(nowOrOptions) {\n        if (nowOrOptions instanceof Date || typeof nowOrOptions === \"number\") {\n            return new Date(nowOrOptions);\n        }\n        if ((nowOrOptions === null || nowOrOptions === void 0 ? void 0 : nowOrOptions.now) !== undefined) {\n            return new Date(nowOrOptions.now);\n        }\n        return getGlobalNow();\n    }\n    function relativeTime(/** The date time that needs to be formatted. */ date, /** The reference point in time to which `date` will be formatted in relation to.  */ nowOrOptions) {\n        try {\n            const dateDate = new Date(date);\n            const nowDate = extractNowDate(nowOrOptions);\n            const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n            const unit = typeof nowOrOptions === \"number\" || nowOrOptions instanceof Date || (nowOrOptions === null || nowOrOptions === void 0 ? void 0 : nowOrOptions.unit) === undefined ? resolveRelativeTimeUnit(seconds) : nowOrOptions.unit;\n            const value = calculateRelativeTimeValue(seconds, unit);\n            return new Intl.RelativeTimeFormat(locale, {\n                // `numeric: 'auto'` can theoretically produce output like \"yesterday\",\n                // but it only works with integers. E.g. -1 day will produce \"yesterday\",\n                // but -1.1 days will produce \"-1.1 days\". Rounding before formatting is\n                // not desired, as the given dates might cross a threshold were the\n                // output isn't correct anymore. Example: 2024-01-08T23:00:00.000Z and\n                // 2024-01-08T01:00:00.000Z would produce \"yesterday\", which is not the\n                // case. By using `always` we can ensure correct output. The only exception\n                // is the formatting of times <1 second as \"now\".\n                numeric: unit === \"second\" ? \"auto\" : \"always\"\n            }).format(value, unit);\n        } catch (error) {\n            onError(new initializeConfig.IntlError(initializeConfig.IntlErrorCode.FORMATTING_ERROR, error.message));\n            return String(date);\n        }\n    }\n    function list(value, formatOrOptions) {\n        const serializedValue = [];\n        const richValues = new Map();\n        // `formatToParts` only accepts strings, therefore we have to temporarily\n        // replace React elements with a placeholder ID that can be used to retrieve\n        // the original value afterwards.\n        let index = 0;\n        for (const item of value){\n            let serializedItem;\n            if (typeof item === \"object\") {\n                serializedItem = String(index);\n                richValues.set(serializedItem, item);\n            } else {\n                serializedItem = String(item);\n            }\n            serializedValue.push(serializedItem);\n            index++;\n        }\n        return getFormattedValue(formatOrOptions, formats === null || formats === void 0 ? void 0 : formats.list, // @ts-expect-error -- `richValues.size` is used to determine the return type, but TypeScript can't infer the meaning of this correctly\n        (options)=>{\n            const result = new Intl.ListFormat(locale, options).formatToParts(serializedValue).map((part)=>part.type === \"literal\" ? part.value : richValues.get(part.value) || part.value);\n            if (richValues.size > 0) {\n                return result;\n            } else {\n                return result.join(\"\");\n            }\n        }, ()=>String(value));\n    }\n    return {\n        dateTime,\n        number,\n        relativeTime,\n        list,\n        dateTimeRange\n    };\n}\nexports.createBaseTranslator = createBaseTranslator;\nexports.createFormatter = createFormatter;\nexports.resolveNamespace = resolveNamespace;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jcmVhdGVGb3JtYXR0ZXItODFkN2U1OTguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxvQkFBb0JDLG1CQUFPQSxDQUFDO0FBQ2hDLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlFLG1CQUFtQkYsbUJBQU9BLENBQUM7QUFFL0IsU0FBU0csZ0JBQWlCQyxDQUFDO0lBQUksT0FBT0EsS0FBS0EsRUFBRUMsVUFBVSxHQUFHRCxJQUFJO1FBQUVFLFNBQVNGO0lBQUU7QUFBRztBQUU5RSxJQUFJRyw2QkFBNkIsV0FBVyxHQUFFSixnQkFBZ0JKO0FBRTlELHdFQUF3RTtBQUN4RSxTQUFTUyxxQkFBcUJDLE9BQU8sRUFBRUMsUUFBUTtJQUM3QyxJQUFJLENBQUNELFNBQVMsT0FBT0E7SUFFckIsNEZBQTRGO0lBQzVGLHNIQUFzSDtJQUN0SCxPQUFPRSxPQUFPQyxJQUFJLENBQUNILFNBQVNJLE1BQU0sQ0FBQyxDQUFDQyxLQUFLQztRQUN2Q0QsR0FBRyxDQUFDQyxJQUFJLEdBQUc7WUFDVEw7WUFDQSxHQUFHRCxPQUFPLENBQUNNLElBQUk7UUFDakI7UUFDQSxPQUFPRDtJQUNULEdBQUcsQ0FBQztBQUNOO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU0Usa0NBQWtDUCxPQUFPLEVBQUVDLFFBQVE7SUFDMUQsTUFBTU8sc0JBQXNCUCxXQUFXO1FBQ3JDLEdBQUdELE9BQU87UUFDVlMsVUFBVVYscUJBQXFCQyxRQUFRUyxRQUFRLEVBQUVSO0lBQ25ELElBQUlEO0lBQ0osTUFBTVUsaUJBQWlCWiwyQkFBMkJELE9BQU8sQ0FBQ0csT0FBTyxDQUFDVyxJQUFJO0lBQ3RFLE1BQU1DLHFCQUFxQlgsV0FBV0YscUJBQXFCVyxnQkFBZ0JULFlBQVlTO0lBQ3ZGLE1BQU1HLGlCQUFpQmYsMkJBQTJCRCxPQUFPLENBQUNHLE9BQU8sQ0FBQ2MsSUFBSTtJQUN0RSxNQUFNQyxx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UUFDakMsSUFBSXhJLFFBQVE7UUFDWixLQUFLLE1BQU15SSxRQUFReEksTUFBTztZQUN4QixJQUFJeUk7WUFDSixJQUFJLE9BQU9ELFNBQVMsVUFBVTtnQkFDNUJDLGlCQUFpQnJHLE9BQU9yQztnQkFDeEJ1SSxXQUFXNUUsR0FBRyxDQUFDK0UsZ0JBQWdCRDtZQUNqQyxPQUFPO2dCQUNMQyxpQkFBaUJyRyxPQUFPb0c7WUFDMUI7WUFDQUgsZ0JBQWdCSyxJQUFJLENBQUNEO1lBQ3JCMUk7UUFDRjtRQUNBLE9BQU9rSCxrQkFBa0JILGlCQUFpQmpKLFlBQVksUUFBUUEsWUFBWSxLQUFLLElBQUksS0FBSyxJQUFJQSxRQUFRdUssSUFBSSxFQUN4Ryx1SUFBdUk7UUFDdkluRixDQUFBQTtZQUNFLE1BQU05QyxTQUFTLElBQUkrQyxLQUFLeUYsVUFBVSxDQUFDN0osUUFBUW1FLFNBQVMyRixhQUFhLENBQUNQLGlCQUFpQlEsR0FBRyxDQUFDckosQ0FBQUEsT0FBUUEsS0FBS3NKLElBQUksS0FBSyxZQUFZdEosS0FBS1EsS0FBSyxHQUFHc0ksV0FBVy9GLEdBQUcsQ0FBQy9DLEtBQUtRLEtBQUssS0FBS1IsS0FBS1EsS0FBSztZQUM5SyxJQUFJc0ksV0FBV1MsSUFBSSxHQUFHLEdBQUc7Z0JBQ3ZCLE9BQU81STtZQUNULE9BQU87Z0JBQ0wsT0FBT0EsT0FBT3FILElBQUksQ0FBQztZQUNyQjtRQUNGLEdBQUcsSUFBTXBGLE9BQU9wQztJQUNsQjtJQUNBLE9BQU87UUFDTDFCO1FBQ0FtSjtRQUNBSztRQUNBTTtRQUNBaEI7SUFDRjtBQUNGO0FBRUE0Qiw0QkFBNEIsR0FBRzFIO0FBQy9CMEgsdUJBQXVCLEdBQUczQztBQUMxQjJDLHdCQUF3QixHQUFHOUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9lbmdsaXNoLWNvdXJzZXMvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9jcmVhdGVGb3JtYXR0ZXItODFkN2U1OTguanM/YzRhNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBJbnRsTWVzc2FnZUZvcm1hdCA9IHJlcXVpcmUoJ2ludGwtbWVzc2FnZWZvcm1hdCcpO1xudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpbml0aWFsaXplQ29uZmlnID0gcmVxdWlyZSgnLi9pbml0aWFsaXplQ29uZmlnLWM1MDNlMjE1LmpzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wRGVmYXVsdCAoZSkgeyByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDogeyBkZWZhdWx0OiBlIH07IH1cblxudmFyIEludGxNZXNzYWdlRm9ybWF0X19kZWZhdWx0ID0gLyojX19QVVJFX18qL19pbnRlcm9wRGVmYXVsdChJbnRsTWVzc2FnZUZvcm1hdCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbmFtZWQtYXMtZGVmYXVsdCAtLSBGYWxzZSBwb3NpdGl2ZVxuZnVuY3Rpb24gc2V0VGltZVpvbmVJbkZvcm1hdHMoZm9ybWF0cywgdGltZVpvbmUpIHtcbiAgaWYgKCFmb3JtYXRzKSByZXR1cm4gZm9ybWF0cztcblxuICAvLyBUaGUgb25seSB3YXkgdG8gc2V0IGEgdGltZSB6b25lIHdpdGggYGludGwtbWVzc2FnZWZvcm1hdGAgaXMgdG8gbWVyZ2UgaXQgaW50byB0aGUgZm9ybWF0c1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZm9ybWF0anMvZm9ybWF0anMvYmxvYi84MjU2YzUyNzE1MDVjZjI2MDZlNDhlM2M5N2VjZGQxNmVkZTRmMWI1L3BhY2thZ2VzL2ludGwvc3JjL21lc3NhZ2UudHMjTDE1XG4gIHJldHVybiBPYmplY3Qua2V5cyhmb3JtYXRzKS5yZWR1Y2UoKGFjYywga2V5KSA9PiB7XG4gICAgYWNjW2tleV0gPSB7XG4gICAgICB0aW1lWm9uZSxcbiAgICAgIC4uLmZvcm1hdHNba2V5XVxuICAgIH07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG4vKipcbiAqIGBpbnRsLW1lc3NhZ2Vmb3JtYXRgIHVzZXMgc2VwYXJhdGUga2V5cyBmb3IgYGRhdGVgIGFuZCBgdGltZWAsIGJ1dCB0aGVyZSdzXG4gKiBvbmx5IG9uZSBuYXRpdmUgQVBJOiBgSW50bC5EYXRlVGltZUZvcm1hdGAuIEFkZGl0aW9uYWxseSB5b3UgbWlnaHQgd2FudCB0b1xuICogaW5jbHVkZSBib3RoIGEgdGltZSBhbmQgYSBkYXRlIGluIGEgdmFsdWUsIHRoZXJlZm9yZSB0aGUgc2VwYXJhdGlvbiBkb2Vzbid0XG4gKiBzZWVtIHNvIHVzZWZ1bC4gV2Ugb2ZmZXIgYSBzaW5nbGUgYGRhdGVUaW1lYCBuYW1lc3BhY2UgaW5zdGVhZCwgYnV0IHdlIGhhdmVcbiAqIHRvIGNvbnZlcnQgdGhlIGZvcm1hdCBiZWZvcmUgYGludGwtbWVzc2FnZWZvcm1hdGAgY2FuIGJlIHVzZWQuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRGb3JtYXRzVG9JbnRsTWVzc2FnZUZvcm1hdChmb3JtYXRzLCB0aW1lWm9uZSkge1xuICBjb25zdCBmb3JtYXRzV2l0aFRpbWVab25lID0gdGltZVpvbmUgPyB7XG4gICAgLi4uZm9ybWF0cyxcbiAgICBkYXRlVGltZTogc2V0VGltZVpvbmVJbkZvcm1hdHMoZm9ybWF0cy5kYXRlVGltZSwgdGltZVpvbmUpXG4gIH0gOiBmb3JtYXRzO1xuICBjb25zdCBtZkRhdGVEZWZhdWx0cyA9IEludGxNZXNzYWdlRm9ybWF0X19kZWZhdWx0LmRlZmF1bHQuZm9ybWF0cy5kYXRlO1xuICBjb25zdCBkZWZhdWx0RGF0ZUZvcm1hdHMgPSB0aW1lWm9uZSA/IHNldFRpbWVab25lSW5Gb3JtYXRzKG1mRGF0ZURlZmF1bHRzLCB0aW1lWm9uZSkgOiBtZkRhdGVEZWZhdWx0cztcbiAgY29uc3QgbWZUaW1lRGVmYXVsdHMgPSBJbnRsTWVzc2FnZUZvcm1hdF9fZGVmYXVsdC5kZWZhdWx0LmZvcm1hdHMudGltZTtcbiAgY29uc3QgZGVmYXVsdFRpbWVGb3JtYXRzID0gdGltZVpvbmUgPyBzZXRUaW1lWm9uZUluRm9ybWF0cyhtZlRpbWVEZWZhdWx0cywgdGltZVpvbmUpIDogbWZUaW1lRGVmYXVsdHM7XG4gIHJldHVybiB7XG4gICAgLi4uZm9ybWF0c1dpdGhUaW1lWm9uZSxcbiAgICBkYXRlOiB7XG4gICAgICAuLi5kZWZhdWx0RGF0ZUZvcm1hdHMsXG4gICAgICAuLi4oZm9ybWF0c1dpdGhUaW1lWm9uZSA9PT0gbnVsbCB8fCBmb3JtYXRzV2l0aFRpbWVab25lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzV2l0aFRpbWVab25lLmRhdGVUaW1lKVxuICAgIH0sXG4gICAgdGltZToge1xuICAgICAgLi4uZGVmYXVsdFRpbWVGb3JtYXRzLFxuICAgICAgLi4uKGZvcm1hdHNXaXRoVGltZVpvbmUgPT09IG51bGwgfHwgZm9ybWF0c1dpdGhUaW1lWm9uZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0c1dpdGhUaW1lWm9uZS5kYXRlVGltZSlcbiAgICB9XG4gIH07XG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tbmFtZWQtYXMtZGVmYXVsdCAtLSBGYWxzZSBwb3NpdGl2ZVxuZnVuY3Rpb24gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpIHtcbiAgY29uc3QgZnVsbEtleSA9IGluaXRpYWxpemVDb25maWcuam9pblBhdGgobmFtZXNwYWNlLCBrZXkpO1xuICBpZiAoIW1lc3NhZ2VzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZXMgYXZhaWxhYmxlIGF0IGBcIi5jb25jYXQobmFtZXNwYWNlLCBcImAuXCIpICk7XG4gIH1cbiAgbGV0IG1lc3NhZ2UgPSBtZXNzYWdlcztcbiAga2V5LnNwbGl0KCcuJykuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBjb25zdCBuZXh0ID0gbWVzc2FnZVtwYXJ0XTtcbiAgICBpZiAocGFydCA9PSBudWxsIHx8IG5leHQgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IHJlc29sdmUgYFwiLmNvbmNhdChmdWxsS2V5LCBcImAgaW4gbWVzc2FnZXMgZm9yIGxvY2FsZSBgXCIpLmNvbmNhdChsb2NhbGUsIFwiYC5cIikgKTtcbiAgICB9XG4gICAgbWVzc2FnZSA9IG5leHQ7XG4gIH0pO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVUcmFuc2xhdGlvblZhbHVlcyh2YWx1ZXMpIHtcbiAgaWYgKE9iamVjdC5rZXlzKHZhbHVlcykubGVuZ3RoID09PSAwKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9mb3JtYXRqcy9mb3JtYXRqcy9pc3N1ZXMvMTQ2N1xuICBjb25zdCB0cmFuc2Zvcm1lZFZhbHVlcyA9IHt9O1xuICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2tleV07XG4gICAgbGV0IHRyYW5zZm9ybWVkO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyYW5zZm9ybWVkID0gY2h1bmtzID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsdWUoY2h1bmtzKTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5pc1ZhbGlkRWxlbWVudChyZXN1bHQpID8gLyojX19QVVJFX18qL1JlYWN0LmNsb25lRWxlbWVudChyZXN1bHQsIHtcbiAgICAgICAgICBrZXk6IGtleSArIGluZGV4KytcbiAgICAgICAgfSkgOiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2Zvcm1lZCA9IHZhbHVlO1xuICAgIH1cbiAgICB0cmFuc2Zvcm1lZFZhbHVlc1trZXldID0gdHJhbnNmb3JtZWQ7XG4gIH0pO1xuICByZXR1cm4gdHJhbnNmb3JtZWRWYWx1ZXM7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlc09yRXJyb3IobG9jYWxlLCBtZXNzYWdlcywgbmFtZXNwYWNlKSB7XG4gIGxldCBvbkVycm9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRPbkVycm9yO1xuICB0cnkge1xuICAgIGlmICghbWVzc2FnZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG1lc3NhZ2VzIHdlcmUgY29uZmlndXJlZCBvbiB0aGUgcHJvdmlkZXIuXCIgKTtcbiAgICB9XG4gICAgY29uc3QgcmV0cmlldmVkTWVzc2FnZXMgPSBuYW1lc3BhY2UgPyByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBuYW1lc3BhY2UpIDogbWVzc2FnZXM7XG4gICAgaWYgKCFyZXRyaWV2ZWRNZXNzYWdlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gbWVzc2FnZXMgZm9yIG5hbWVzcGFjZSBgXCIuY29uY2F0KG5hbWVzcGFjZSwgXCJgIGZvdW5kLlwiKSApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0cmlldmVkTWVzc2FnZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgaW50bEVycm9yID0gbmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIG9uRXJyb3IoaW50bEVycm9yKTtcbiAgICByZXR1cm4gaW50bEVycm9yO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQbGFpbk1lc3NhZ2UoY2FuZGlkYXRlLCB2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcykgcmV0dXJuIHVuZGVmaW5lZDtcbiAgY29uc3QgdW5lc2NhcGVkTWVzc2FnZSA9IGNhbmRpZGF0ZS5yZXBsYWNlKC8nKFt7fV0pL2dpLCAnJDEnKTtcblxuICAvLyBQbGFjZWhvbGRlcnMgY2FuIGJlIGluIHRoZSBtZXNzYWdlIGlmIHRoZXJlIGFyZSBkZWZhdWx0IHZhbHVlcyxcbiAgLy8gb3IgaWYgdGhlIHVzZXIgaGFzIGZvcmdvdHRlbiB0byBwcm92aWRlIHZhbHVlcy4gSW4gdGhlIGxhdHRlclxuICAvLyBjYXNlIHdlIG5lZWQgdG8gY29tcGlsZSB0aGUgbWVzc2FnZSB0byByZWNlaXZlIGFuIGVycm9yLlxuICBjb25zdCBoYXNQbGFjZWhvbGRlcnMgPSAvPHx7Ly50ZXN0KHVuZXNjYXBlZE1lc3NhZ2UpO1xuICBpZiAoIWhhc1BsYWNlaG9sZGVycykge1xuICAgIHJldHVybiB1bmVzY2FwZWRNZXNzYWdlO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBjcmVhdGVCYXNlVHJhbnNsYXRvcihjb25maWcpIHtcbiAgY29uc3QgbWVzc2FnZXNPckVycm9yID0gZ2V0TWVzc2FnZXNPckVycm9yKGNvbmZpZy5sb2NhbGUsIGNvbmZpZy5tZXNzYWdlcywgY29uZmlnLm5hbWVzcGFjZSwgY29uZmlnLm9uRXJyb3IpO1xuICByZXR1cm4gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKHtcbiAgICAuLi5jb25maWcsXG4gICAgbWVzc2FnZXNPckVycm9yXG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlQmFzZVRyYW5zbGF0b3JJbXBsKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMsXG4gICAgZm9ybWF0czogZ2xvYmFsRm9ybWF0cyxcbiAgICBnZXRNZXNzYWdlRmFsbGJhY2sgPSBpbml0aWFsaXplQ29uZmlnLmRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2ssXG4gICAgbG9jYWxlLFxuICAgIG1lc3NhZ2VGb3JtYXRDYWNoZSxcbiAgICBtZXNzYWdlc09yRXJyb3IsXG4gICAgbmFtZXNwYWNlLFxuICAgIG9uRXJyb3IsXG4gICAgdGltZVpvbmVcbiAgfSA9IF9yZWY7XG4gIGZ1bmN0aW9uIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgY29kZSwgbWVzc2FnZSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGNvZGUsIG1lc3NhZ2UpO1xuICAgIG9uRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgZXJyb3IsXG4gICAgICBrZXksXG4gICAgICBuYW1lc3BhY2VcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2xhdGVCYXNlRm4oIC8qKiBVc2UgYSBkb3QgdG8gaW5kaWNhdGUgYSBsZXZlbCBvZiBuZXN0aW5nIChlLmcuIGBuYW1lc3BhY2UubmVzdGVkTGFiZWxgKS4gKi9cbiAga2V5LCAvKiogS2V5IHZhbHVlIHBhaXJzIGZvciB2YWx1ZXMgdG8gaW50ZXJwb2xhdGUgaW50byB0aGUgbWVzc2FnZS4gKi9cbiAgdmFsdWVzLCAvKiogUHJvdmlkZSBjdXN0b20gZm9ybWF0cyBmb3IgbnVtYmVycywgZGF0ZXMgYW5kIHRpbWVzLiAqL1xuICBmb3JtYXRzKSB7XG4gICAgaWYgKG1lc3NhZ2VzT3JFcnJvciBpbnN0YW5jZW9mIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKSB7XG4gICAgICAvLyBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0IHRoaXMgZHVyaW5nIHJlbmRlclxuICAgICAgcmV0dXJuIGdldE1lc3NhZ2VGYWxsYmFjayh7XG4gICAgICAgIGVycm9yOiBtZXNzYWdlc09yRXJyb3IsXG4gICAgICAgIGtleSxcbiAgICAgICAgbmFtZXNwYWNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZXMgPSBtZXNzYWdlc09yRXJyb3I7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgdHJ5IHtcbiAgICAgIG1lc3NhZ2UgPSByZXNvbHZlUGF0aChsb2NhbGUsIG1lc3NhZ2VzLCBrZXksIG5hbWVzcGFjZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBnZXRGYWxsYmFja0Zyb21FcnJvckFuZE5vdGlmeShrZXksIGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5NSVNTSU5HX01FU1NBR0UsIGVycm9yLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBjYWNoZUtleSA9IGluaXRpYWxpemVDb25maWcuam9pblBhdGgobG9jYWxlLCBuYW1lc3BhY2UsIGtleSwgU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICBsZXQgbWVzc2FnZUZvcm1hdDtcbiAgICBpZiAobWVzc2FnZUZvcm1hdENhY2hlICE9PSBudWxsICYmIG1lc3NhZ2VGb3JtYXRDYWNoZSAhPT0gdm9pZCAwICYmIG1lc3NhZ2VGb3JtYXRDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICBtZXNzYWdlRm9ybWF0ID0gbWVzc2FnZUZvcm1hdENhY2hlLmdldChjYWNoZUtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgbGV0IGNvZGUsIGVycm9yTWVzc2FnZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWVzc2FnZSkpIHtcbiAgICAgICAgICBjb2RlID0gaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIk1lc3NhZ2UgYXQgYFwiLmNvbmNhdChpbml0aWFsaXplQ29uZmlnLmpvaW5QYXRoKG5hbWVzcGFjZSwga2V5KSwgXCJgIHJlc29sdmVkIHRvIGFuIGFycmF5LCBidXQgb25seSBzdHJpbmdzIGFyZSBzdXBwb3J0ZWQuIFNlZSBodHRwczovL25leHQtaW50bC1kb2NzLnZlcmNlbC5hcHAvZG9jcy91c2FnZS9tZXNzYWdlcyNhcnJheXMtb2YtbWVzc2FnZXNcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvZGUgPSBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5TVUZGSUNJRU5UX1BBVEg7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJNZXNzYWdlIGF0IGBcIi5jb25jYXQoaW5pdGlhbGl6ZUNvbmZpZy5qb2luUGF0aChuYW1lc3BhY2UsIGtleSksIFwiYCByZXNvbHZlZCB0byBhbiBvYmplY3QsIGJ1dCBvbmx5IHN0cmluZ3MgYXJlIHN1cHBvcnRlZC4gVXNlIGEgYC5gIHRvIHJldHJpZXZlIG5lc3RlZCBtZXNzYWdlcy4gU2VlIGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL3VzYWdlL21lc3NhZ2VzI3N0cnVjdHVyaW5nLW1lc3NhZ2VzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBjb2RlLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBIb3QgcGF0aCB0aGF0IGF2b2lkcyBjcmVhdGluZyBhbiBgSW50bE1lc3NhZ2VGb3JtYXRgIGluc3RhbmNlXG4gICAgICBjb25zdCBwbGFpbk1lc3NhZ2UgPSBnZXRQbGFpbk1lc3NhZ2UobWVzc2FnZSwgdmFsdWVzKTtcbiAgICAgIGlmIChwbGFpbk1lc3NhZ2UpIHJldHVybiBwbGFpbk1lc3NhZ2U7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlRm9ybWF0ID0gbmV3IEludGxNZXNzYWdlRm9ybWF0X19kZWZhdWx0LmRlZmF1bHQobWVzc2FnZSwgbG9jYWxlLCBjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQoe1xuICAgICAgICAgIC4uLmdsb2JhbEZvcm1hdHMsXG4gICAgICAgICAgLi4uZm9ybWF0c1xuICAgICAgICB9LCB0aW1lWm9uZSksIHtcbiAgICAgICAgICBmb3JtYXR0ZXJzOiB7XG4gICAgICAgICAgICBnZXROdW1iZXJGb3JtYXQobG9jYWxlcywgb3B0aW9ucykge1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IEludGwuTnVtYmVyRm9ybWF0KGxvY2FsZXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldERhdGVUaW1lRm9ybWF0KGxvY2FsZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL2Zvcm1hdGpzL2Zvcm1hdGpzL2lzc3Vlcy80Mjc5XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGVzLCB7XG4gICAgICAgICAgICAgICAgdGltZVpvbmUsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9uc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRQbHVyYWxSdWxlcyhsb2NhbGVzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgSW50bC5QbHVyYWxSdWxlcyhsb2NhbGVzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgdGhyb3duRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgcmV0dXJuIGdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5KGtleSwgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLklOVkFMSURfTUVTU0FHRSwgdGhyb3duRXJyb3IubWVzc2FnZSArICgnb3JpZ2luYWxNZXNzYWdlJyBpbiB0aHJvd25FcnJvciA/IFwiIChcIi5jb25jYXQodGhyb3duRXJyb3Iub3JpZ2luYWxNZXNzYWdlLCBcIilcIikgOiAnJykgKTtcbiAgICAgIH1cbiAgICAgIG1lc3NhZ2VGb3JtYXRDYWNoZSA9PT0gbnVsbCB8fCBtZXNzYWdlRm9ybWF0Q2FjaGUgPT09IHZvaWQgMCB8fCBtZXNzYWdlRm9ybWF0Q2FjaGUuc2V0KGNhY2hlS2V5LCBtZXNzYWdlRm9ybWF0KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGZvcm1hdHRlZE1lc3NhZ2UgPSBtZXNzYWdlRm9ybWF0LmZvcm1hdChcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYGludGwtbWVzc2FnZWZvcm1hdGAgZXhwZWN0cyBhIGRpZmZlcmVudCBmb3JtYXRcbiAgICAgIC8vIGZvciByaWNoIHRleHQgZWxlbWVudHMgc2luY2UgYSByZWNlbnQgbWlub3IgdXBkYXRlLiBUaGlzXG4gICAgICAvLyBuZWVkcyB0byBiZSBldmFsdWF0ZWQgaW4gZGV0YWlsLCBwb3NzaWJseSBhbHNvIGluIHJlZ2FyZHNcbiAgICAgIC8vIHRvIGJlIGFibGUgdG8gZm9ybWF0IHRvIHBhcnRzLlxuICAgICAgcHJlcGFyZVRyYW5zbGF0aW9uVmFsdWVzKHtcbiAgICAgICAgLi4uZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzLFxuICAgICAgICAuLi52YWx1ZXNcbiAgICAgIH0pKTtcbiAgICAgIGlmIChmb3JtYXR0ZWRNZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGZvcm1hdCBgXCIuY29uY2F0KGtleSwgXCJgIGluIFwiKS5jb25jYXQobmFtZXNwYWNlID8gXCJuYW1lc3BhY2UgYFwiLmNvbmNhdChuYW1lc3BhY2UsIFwiYFwiKSA6ICdtZXNzYWdlcycpICk7XG4gICAgICB9XG5cbiAgICAgIC8vIExpbWl0IHRoZSBmdW5jdGlvbiBzaWduYXR1cmUgdG8gcmV0dXJuIHN0cmluZ3Mgb3IgUmVhY3QgZWxlbWVudHNcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuaXNWYWxpZEVsZW1lbnQoZm9ybWF0dGVkTWVzc2FnZSkgfHxcbiAgICAgIC8vIEFycmF5cyBvZiBSZWFjdCBlbGVtZW50c1xuICAgICAgQXJyYXkuaXNBcnJheShmb3JtYXR0ZWRNZXNzYWdlKSB8fCB0eXBlb2YgZm9ybWF0dGVkTWVzc2FnZSA9PT0gJ3N0cmluZycgPyBmb3JtYXR0ZWRNZXNzYWdlIDogU3RyaW5nKGZvcm1hdHRlZE1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRk9STUFUVElOR19FUlJPUiwgZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUZuKCAvKiogVXNlIGEgZG90IHRvIGluZGljYXRlIGEgbGV2ZWwgb2YgbmVzdGluZyAoZS5nLiBgbmFtZXNwYWNlLm5lc3RlZExhYmVsYCkuICovXG4gIGtleSwgLyoqIEtleSB2YWx1ZSBwYWlycyBmb3IgdmFsdWVzIHRvIGludGVycG9sYXRlIGludG8gdGhlIG1lc3NhZ2UuICovXG4gIHZhbHVlcywgLyoqIFByb3ZpZGUgY3VzdG9tIGZvcm1hdHMgZm9yIG51bWJlcnMsIGRhdGVzIGFuZCB0aW1lcy4gKi9cbiAgZm9ybWF0cykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zbGF0ZUJhc2VGbihrZXksIHZhbHVlcywgZm9ybWF0cyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuSU5WQUxJRF9NRVNTQUdFLCBcIlRoZSBtZXNzYWdlIGBcIi5jb25jYXQoa2V5LCBcImAgaW4gXCIpLmNvbmNhdChuYW1lc3BhY2UgPyBcIm5hbWVzcGFjZSBgXCIuY29uY2F0KG5hbWVzcGFjZSwgXCJgXCIpIDogJ21lc3NhZ2VzJywgXCIgZGlkbid0IHJlc29sdmUgdG8gYSBzdHJpbmcuIElmIHlvdSB3YW50IHRvIGZvcm1hdCByaWNoIHRleHQsIHVzZSBgdC5yaWNoYCBpbnN0ZWFkLlwiKSApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHRyYW5zbGF0ZUZuLnJpY2ggPSB0cmFuc2xhdGVCYXNlRm47XG5cbiAgLy8gQXVnbWVudCBgdHJhbnNsYXRlQmFzZUZuYCB0byByZXR1cm4gcGxhaW4gc3RyaW5nc1xuICB0cmFuc2xhdGVGbi5tYXJrdXAgPSAoa2V5LCB2YWx1ZXMsIGZvcm1hdHMpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB0cmFuc2xhdGVCYXNlRm4oa2V5LFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gYE1hcmt1cFRyYW5zbGF0aW9uVmFsdWVzYCBpcyBwcmFjdGljYWxseSBhIHN1YiB0eXBlXG4gICAgLy8gb2YgYFJpY2hUcmFuc2xhdGlvblZhbHVlc2AgYnV0IFR5cGVTY3JpcHQgaXNuJ3Qgc21hcnQgZW5vdWdoIGhlcmUuXG4gICAgdmFsdWVzLCBmb3JtYXRzKTtcblxuICAgIC8vIFdoZW4gb25seSBzdHJpbmcgY2h1bmtzIGFyZSBwcm92aWRlZCB0byB0aGUgcGFyc2VyLCBvbmx5XG4gICAgLy8gc3RyaW5ncyBzaG91bGQgYmUgcmV0dXJuZWQgaGVyZS4gTm90ZSB0aGF0IHdlIG5lZWQgYSBydW50aW1lXG4gICAgLy8gY2hlY2sgZm9yIHRoaXMgc2luY2UgcmljaCB0ZXh0IHZhbHVlcyBjb3VsZCBiZSBhY2NpZGVudGFsbHlcbiAgICAvLyBpbmhlcml0ZWQgZnJvbSBgZGVmYXVsdFRyYW5zbGF0aW9uVmFsdWVzYC5cbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBcImB0Lm1hcmt1cGAgb25seSBhY2NlcHRzIGZ1bmN0aW9ucyBmb3IgZm9ybWF0dGluZyB0aGF0IHJlY2VpdmUgYW5kIHJldHVybiBzdHJpbmdzLlxcblxcbkUuZy4gdC5tYXJrdXAoJ21hcmt1cCcsIHtiOiAoY2h1bmtzKSA9PiBgPGI+JHtjaHVua3N9PC9iPmB9KVwiICk7XG4gICAgICBvbkVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcixcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lc3BhY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICB0cmFuc2xhdGVGbi5yYXcgPSBrZXkgPT4ge1xuICAgIGlmIChtZXNzYWdlc09yRXJyb3IgaW5zdGFuY2VvZiBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcikge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dCB0aGlzIGR1cmluZyByZW5kZXJcbiAgICAgIHJldHVybiBnZXRNZXNzYWdlRmFsbGJhY2soe1xuICAgICAgICBlcnJvcjogbWVzc2FnZXNPckVycm9yLFxuICAgICAgICBrZXksXG4gICAgICAgIG5hbWVzcGFjZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2VzID0gbWVzc2FnZXNPckVycm9yO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZVBhdGgobG9jYWxlLCBtZXNzYWdlcywga2V5LCBuYW1lc3BhY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2tGcm9tRXJyb3JBbmROb3RpZnkoa2V5LCBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuTUlTU0lOR19NRVNTQUdFLCBlcnJvci5tZXNzYWdlKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFuc2xhdGVGbjtcbn1cblxuLyoqXG4gKiBGb3IgdGhlIHN0cmljdGx5IHR5cGVkIG1lc3NhZ2VzIHRvIHdvcmsgd2UgaGF2ZSB0byB3cmFwIHRoZSBuYW1lc3BhY2UgaW50b1xuICogYSBtYW5kYXRvcnkgcHJlZml4LiBTZWUgaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNTI5NTc1LzM0MzA0NVxuICovXG5mdW5jdGlvbiByZXNvbHZlTmFtZXNwYWNlKG5hbWVzcGFjZSwgbmFtZXNwYWNlUHJlZml4KSB7XG4gIHJldHVybiBuYW1lc3BhY2UgPT09IG5hbWVzcGFjZVByZWZpeCA/IHVuZGVmaW5lZCA6IG5hbWVzcGFjZS5zbGljZSgobmFtZXNwYWNlUHJlZml4ICsgJy4nKS5sZW5ndGgpO1xufVxuXG5jb25zdCBTRUNPTkQgPSAxO1xuY29uc3QgTUlOVVRFID0gU0VDT05EICogNjA7XG5jb25zdCBIT1VSID0gTUlOVVRFICogNjA7XG5jb25zdCBEQVkgPSBIT1VSICogMjQ7XG5jb25zdCBXRUVLID0gREFZICogNztcbmNvbnN0IE1PTlRIID0gREFZICogKDM2NSAvIDEyKTsgLy8gQXBwcm94aW1hdGlvblxuY29uc3QgUVVBUlRFUiA9IE1PTlRIICogMztcbmNvbnN0IFlFQVIgPSBEQVkgKiAzNjU7XG5jb25zdCBVTklUX1NFQ09ORFMgPSB7XG4gIHNlY29uZDogU0VDT05ELFxuICBzZWNvbmRzOiBTRUNPTkQsXG4gIG1pbnV0ZTogTUlOVVRFLFxuICBtaW51dGVzOiBNSU5VVEUsXG4gIGhvdXI6IEhPVVIsXG4gIGhvdXJzOiBIT1VSLFxuICBkYXk6IERBWSxcbiAgZGF5czogREFZLFxuICB3ZWVrOiBXRUVLLFxuICB3ZWVrczogV0VFSyxcbiAgbW9udGg6IE1PTlRILFxuICBtb250aHM6IE1PTlRILFxuICBxdWFydGVyOiBRVUFSVEVSLFxuICBxdWFydGVyczogUVVBUlRFUixcbiAgeWVhcjogWUVBUixcbiAgeWVhcnM6IFlFQVJcbn07XG5mdW5jdGlvbiByZXNvbHZlUmVsYXRpdmVUaW1lVW5pdChzZWNvbmRzKSB7XG4gIGNvbnN0IGFic1ZhbHVlID0gTWF0aC5hYnMoc2Vjb25kcyk7XG4gIGlmIChhYnNWYWx1ZSA8IE1JTlVURSkge1xuICAgIHJldHVybiAnc2Vjb25kJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IEhPVVIpIHtcbiAgICByZXR1cm4gJ21pbnV0ZSc7XG4gIH0gZWxzZSBpZiAoYWJzVmFsdWUgPCBEQVkpIHtcbiAgICByZXR1cm4gJ2hvdXInO1xuICB9IGVsc2UgaWYgKGFic1ZhbHVlIDwgV0VFSykge1xuICAgIHJldHVybiAnZGF5JztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IE1PTlRIKSB7XG4gICAgcmV0dXJuICd3ZWVrJztcbiAgfSBlbHNlIGlmIChhYnNWYWx1ZSA8IFlFQVIpIHtcbiAgICByZXR1cm4gJ21vbnRoJztcbiAgfVxuICByZXR1cm4gJ3llYXInO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCkge1xuICAvLyBXZSBoYXZlIHRvIHJvdW5kIHRoZSByZXN1bHRpbmcgdmFsdWVzLCBhcyBgSW50bC5SZWxhdGl2ZVRpbWVGb3JtYXRgXG4gIC8vIHdpbGwgaW5jbHVkZSBmcmFjdGlvbnMgbGlrZSAnMi4xIGhvdXJzIGFnbycuXG4gIHJldHVybiBNYXRoLnJvdW5kKHNlY29uZHMgLyBVTklUX1NFQ09ORFNbdW5pdF0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRm9ybWF0dGVyKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBmb3JtYXRzLFxuICAgIGxvY2FsZSxcbiAgICBub3c6IGdsb2JhbE5vdyxcbiAgICBvbkVycm9yID0gaW5pdGlhbGl6ZUNvbmZpZy5kZWZhdWx0T25FcnJvcixcbiAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgfSA9IF9yZWY7XG4gIGZ1bmN0aW9uIGFwcGx5VGltZVpvbmUob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucztcbiAgICBpZiAoISgoX29wdGlvbnMgPSBvcHRpb25zKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyAhPT0gdm9pZCAwICYmIF9vcHRpb25zLnRpbWVab25lKSkge1xuICAgICAgaWYgKGdsb2JhbFRpbWVab25lKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7XG4gICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICB0aW1lWm9uZTogZ2xvYmFsVGltZVpvbmVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5FTlZJUk9OTUVOVF9GQUxMQkFDSywgXCJUaGUgYHRpbWVab25lYCBwYXJhbWV0ZXIgd2Fzbid0IHByb3ZpZGVkIGFuZCB0aGVyZSBpcyBubyBnbG9iYWwgZGVmYXVsdCBjb25maWd1cmVkLiBDb25zaWRlciBhZGRpbmcgYSBnbG9iYWwgZGVmYXVsdCB0byBhdm9pZCBtYXJrdXAgbWlzbWF0Y2hlcyBjYXVzZWQgYnkgZW52aXJvbm1lbnQgZGlmZmVyZW5jZXMuIExlYXJuIG1vcmU6IGh0dHBzOi8vbmV4dC1pbnRsLWRvY3MudmVyY2VsLmFwcC9kb2NzL2NvbmZpZ3VyYXRpb24jdGltZS16b25lXCIgKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xuICB9XG4gIGZ1bmN0aW9uIHJlc29sdmVGb3JtYXRPck9wdGlvbnModHlwZUZvcm1hdHMsIGZvcm1hdE9yT3B0aW9ucykge1xuICAgIGxldCBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgZm9ybWF0T3JPcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZm9ybWF0TmFtZSA9IGZvcm1hdE9yT3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB0eXBlRm9ybWF0cyA9PT0gbnVsbCB8fCB0eXBlRm9ybWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHlwZUZvcm1hdHNbZm9ybWF0TmFtZV07XG4gICAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3IoaW5pdGlhbGl6ZUNvbmZpZy5JbnRsRXJyb3JDb2RlLk1JU1NJTkdfRk9STUFULCBcIkZvcm1hdCBgXCIuY29uY2F0KGZvcm1hdE5hbWUsIFwiYCBpcyBub3QgYXZhaWxhYmxlLiBZb3UgY2FuIGNvbmZpZ3VyZSBpdCBvbiB0aGUgcHJvdmlkZXIgb3IgcHJvdmlkZSBjdXN0b20gb3B0aW9ucy5cIikgKTtcbiAgICAgICAgb25FcnJvcihlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zID0gZm9ybWF0T3JPcHRpb25zO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfVxuICBmdW5jdGlvbiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIHR5cGVGb3JtYXRzLCBmb3JtYXR0ZXIsIGdldEZhbGxiYWNrKSB7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgdHJ5IHtcbiAgICAgIG9wdGlvbnMgPSByZXNvbHZlRm9ybWF0T3JPcHRpb25zKHR5cGVGb3JtYXRzLCBmb3JtYXRPck9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmb3JtYXR0ZXIob3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICByZXR1cm4gZ2V0RmFsbGJhY2soKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWUoIC8qKiBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgdGhpcyBpcyBpbnRlcnByZXRlZCBhcyBhIFVUQyB0aW1lc3RhbXAuICovXG4gIHZhbHVlLFxuICAvKiogSWYgYSB0aW1lIHpvbmUgaXMgc3VwcGxpZWQsIHRoZSBgdmFsdWVgIGlzIGNvbnZlcnRlZCB0byB0aGF0IHRpbWUgem9uZS5cbiAgICogT3RoZXJ3aXNlIHRoZSB1c2VyIHRpbWUgem9uZSB3aWxsIGJlIHVzZWQuICovXG4gIGZvcm1hdE9yT3B0aW9ucykge1xuICAgIHJldHVybiBnZXRGb3JtYXR0ZWRWYWx1ZShmb3JtYXRPck9wdGlvbnMsIGZvcm1hdHMgPT09IG51bGwgfHwgZm9ybWF0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZm9ybWF0cy5kYXRlVGltZSwgb3B0aW9ucyA9PiB7XG4gICAgICBvcHRpb25zID0gYXBwbHlUaW1lWm9uZShvcHRpb25zKTtcbiAgICAgIHJldHVybiBuZXcgSW50bC5EYXRlVGltZUZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSk7XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZGF0ZVRpbWVSYW5nZSggLyoqIElmIGEgbnVtYmVyIGlzIHN1cHBsaWVkLCB0aGlzIGlzIGludGVycHJldGVkIGFzIGEgVVRDIHRpbWVzdGFtcC4gKi9cbiAgc3RhcnQsIC8qKiBJZiBhIG51bWJlciBpcyBzdXBwbGllZCwgdGhpcyBpcyBpbnRlcnByZXRlZCBhcyBhIFVUQyB0aW1lc3RhbXAuICovXG4gIGVuZCxcbiAgLyoqIElmIGEgdGltZSB6b25lIGlzIHN1cHBsaWVkLCB0aGUgdmFsdWVzIGFyZSBjb252ZXJ0ZWQgdG8gdGhhdCB0aW1lIHpvbmUuXG4gICAqIE90aGVyd2lzZSB0aGUgdXNlciB0aW1lIHpvbmUgd2lsbCBiZSB1c2VkLiAqL1xuICBmb3JtYXRPck9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBmb3JtYXRzID09PSBudWxsIHx8IGZvcm1hdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHMuZGF0ZVRpbWUsIG9wdGlvbnMgPT4ge1xuICAgICAgb3B0aW9ucyA9IGFwcGx5VGltZVpvbmUob3B0aW9ucyk7XG4gICAgICByZXR1cm4gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQobG9jYWxlLCBvcHRpb25zKS5mb3JtYXRSYW5nZShzdGFydCwgZW5kKTtcbiAgICB9LCAoKSA9PiBbZGF0ZVRpbWUoc3RhcnQpLCBkYXRlVGltZShlbmQpXS5qb2luKCfigInigJPigIknKSk7XG4gIH1cbiAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlLCBmb3JtYXRPck9wdGlvbnMpIHtcbiAgICByZXR1cm4gZ2V0Rm9ybWF0dGVkVmFsdWUoZm9ybWF0T3JPcHRpb25zLCBmb3JtYXRzID09PSBudWxsIHx8IGZvcm1hdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZvcm1hdHMubnVtYmVyLCBvcHRpb25zID0+IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIG9wdGlvbnMpLmZvcm1hdCh2YWx1ZSksICgpID0+IFN0cmluZyh2YWx1ZSkpO1xuICB9XG4gIGZ1bmN0aW9uIGdldEdsb2JhbE5vdygpIHtcbiAgICBpZiAoZ2xvYmFsTm93KSB7XG4gICAgICByZXR1cm4gZ2xvYmFsTm93O1xuICAgIH0gZWxzZSB7XG4gICAgICBvbkVycm9yKG5ldyBpbml0aWFsaXplQ29uZmlnLkludGxFcnJvcihpbml0aWFsaXplQ29uZmlnLkludGxFcnJvckNvZGUuRU5WSVJPTk1FTlRfRkFMTEJBQ0ssIFwiVGhlIGBub3dgIHBhcmFtZXRlciB3YXNuJ3QgcHJvdmlkZWQgYW5kIHRoZXJlIGlzIG5vIGdsb2JhbCBkZWZhdWx0IGNvbmZpZ3VyZWQuIENvbnNpZGVyIGFkZGluZyBhIGdsb2JhbCBkZWZhdWx0IHRvIGF2b2lkIG1hcmt1cCBtaXNtYXRjaGVzIGNhdXNlZCBieSBlbnZpcm9ubWVudCBkaWZmZXJlbmNlcy4gTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0LWludGwtZG9jcy52ZXJjZWwuYXBwL2RvY3MvY29uZmlndXJhdGlvbiNub3dcIiApKTtcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBleHRyYWN0Tm93RGF0ZShub3dPck9wdGlvbnMpIHtcbiAgICBpZiAobm93T3JPcHRpb25zIGluc3RhbmNlb2YgRGF0ZSB8fCB0eXBlb2Ygbm93T3JPcHRpb25zID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKG5vd09yT3B0aW9ucyk7XG4gICAgfVxuICAgIGlmICgobm93T3JPcHRpb25zID09PSBudWxsIHx8IG5vd09yT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm93T3JPcHRpb25zLm5vdykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKG5vd09yT3B0aW9ucy5ub3cpO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0R2xvYmFsTm93KCk7XG4gIH1cbiAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lKCAvKiogVGhlIGRhdGUgdGltZSB0aGF0IG5lZWRzIHRvIGJlIGZvcm1hdHRlZC4gKi9cbiAgZGF0ZSwgLyoqIFRoZSByZWZlcmVuY2UgcG9pbnQgaW4gdGltZSB0byB3aGljaCBgZGF0ZWAgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gcmVsYXRpb24gdG8uICAqL1xuICBub3dPck9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGF0ZURhdGUgPSBuZXcgRGF0ZShkYXRlKTtcbiAgICAgIGNvbnN0IG5vd0RhdGUgPSBleHRyYWN0Tm93RGF0ZShub3dPck9wdGlvbnMpO1xuICAgICAgY29uc3Qgc2Vjb25kcyA9IChkYXRlRGF0ZS5nZXRUaW1lKCkgLSBub3dEYXRlLmdldFRpbWUoKSkgLyAxMDAwO1xuICAgICAgY29uc3QgdW5pdCA9IHR5cGVvZiBub3dPck9wdGlvbnMgPT09ICdudW1iZXInIHx8IG5vd09yT3B0aW9ucyBpbnN0YW5jZW9mIERhdGUgfHwgKG5vd09yT3B0aW9ucyA9PT0gbnVsbCB8fCBub3dPck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vd09yT3B0aW9ucy51bml0KSA9PT0gdW5kZWZpbmVkID8gcmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQoc2Vjb25kcykgOiBub3dPck9wdGlvbnMudW5pdDtcbiAgICAgIGNvbnN0IHZhbHVlID0gY2FsY3VsYXRlUmVsYXRpdmVUaW1lVmFsdWUoc2Vjb25kcywgdW5pdCk7XG4gICAgICByZXR1cm4gbmV3IEludGwuUmVsYXRpdmVUaW1lRm9ybWF0KGxvY2FsZSwge1xuICAgICAgICAvLyBgbnVtZXJpYzogJ2F1dG8nYCBjYW4gdGhlb3JldGljYWxseSBwcm9kdWNlIG91dHB1dCBsaWtlIFwieWVzdGVyZGF5XCIsXG4gICAgICAgIC8vIGJ1dCBpdCBvbmx5IHdvcmtzIHdpdGggaW50ZWdlcnMuIEUuZy4gLTEgZGF5IHdpbGwgcHJvZHVjZSBcInllc3RlcmRheVwiLFxuICAgICAgICAvLyBidXQgLTEuMSBkYXlzIHdpbGwgcHJvZHVjZSBcIi0xLjEgZGF5c1wiLiBSb3VuZGluZyBiZWZvcmUgZm9ybWF0dGluZyBpc1xuICAgICAgICAvLyBub3QgZGVzaXJlZCwgYXMgdGhlIGdpdmVuIGRhdGVzIG1pZ2h0IGNyb3NzIGEgdGhyZXNob2xkIHdlcmUgdGhlXG4gICAgICAgIC8vIG91dHB1dCBpc24ndCBjb3JyZWN0IGFueW1vcmUuIEV4YW1wbGU6IDIwMjQtMDEtMDhUMjM6MDA6MDAuMDAwWiBhbmRcbiAgICAgICAgLy8gMjAyNC0wMS0wOFQwMTowMDowMC4wMDBaIHdvdWxkIHByb2R1Y2UgXCJ5ZXN0ZXJkYXlcIiwgd2hpY2ggaXMgbm90IHRoZVxuICAgICAgICAvLyBjYXNlLiBCeSB1c2luZyBgYWx3YXlzYCB3ZSBjYW4gZW5zdXJlIGNvcnJlY3Qgb3V0cHV0LiBUaGUgb25seSBleGNlcHRpb25cbiAgICAgICAgLy8gaXMgdGhlIGZvcm1hdHRpbmcgb2YgdGltZXMgPDEgc2Vjb25kIGFzIFwibm93XCIuXG4gICAgICAgIG51bWVyaWM6IHVuaXQgPT09ICdzZWNvbmQnID8gJ2F1dG8nIDogJ2Fsd2F5cydcbiAgICAgIH0pLmZvcm1hdCh2YWx1ZSwgdW5pdCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uRXJyb3IobmV3IGluaXRpYWxpemVDb25maWcuSW50bEVycm9yKGluaXRpYWxpemVDb25maWcuSW50bEVycm9yQ29kZS5GT1JNQVRUSU5HX0VSUk9SLCBlcnJvci5tZXNzYWdlKSk7XG4gICAgICByZXR1cm4gU3RyaW5nKGRhdGUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBsaXN0KHZhbHVlLCBmb3JtYXRPck9wdGlvbnMpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVmFsdWUgPSBbXTtcbiAgICBjb25zdCByaWNoVmFsdWVzID0gbmV3IE1hcCgpO1xuXG4gICAgLy8gYGZvcm1hdFRvUGFydHNgIG9ubHkgYWNjZXB0cyBzdHJpbmdzLCB0aGVyZWZvcmUgd2UgaGF2ZSB0byB0ZW1wb3JhcmlseVxuICAgIC8vIHJlcGxhY2UgUmVhY3QgZWxlbWVudHMgd2l0aCBhIHBsYWNlaG9sZGVyIElEIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmV0cmlldmVcbiAgICAvLyB0aGUgb3JpZ2luYWwgdmFsdWUgYWZ0ZXJ3YXJkcy5cbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgbGV0IHNlcmlhbGl6ZWRJdGVtO1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xuICAgICAgICBzZXJpYWxpemVkSXRlbSA9IFN0cmluZyhpbmRleCk7XG4gICAgICAgIHJpY2hWYWx1ZXMuc2V0KHNlcmlhbGl6ZWRJdGVtLCBpdGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlcmlhbGl6ZWRJdGVtID0gU3RyaW5nKGl0ZW0pO1xuICAgICAgfVxuICAgICAgc2VyaWFsaXplZFZhbHVlLnB1c2goc2VyaWFsaXplZEl0ZW0pO1xuICAgICAgaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIGdldEZvcm1hdHRlZFZhbHVlKGZvcm1hdE9yT3B0aW9ucywgZm9ybWF0cyA9PT0gbnVsbCB8fCBmb3JtYXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JtYXRzLmxpc3QsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciAtLSBgcmljaFZhbHVlcy5zaXplYCBpcyB1c2VkIHRvIGRldGVybWluZSB0aGUgcmV0dXJuIHR5cGUsIGJ1dCBUeXBlU2NyaXB0IGNhbid0IGluZmVyIHRoZSBtZWFuaW5nIG9mIHRoaXMgY29ycmVjdGx5XG4gICAgb3B0aW9ucyA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBuZXcgSW50bC5MaXN0Rm9ybWF0KGxvY2FsZSwgb3B0aW9ucykuZm9ybWF0VG9QYXJ0cyhzZXJpYWxpemVkVmFsdWUpLm1hcChwYXJ0ID0+IHBhcnQudHlwZSA9PT0gJ2xpdGVyYWwnID8gcGFydC52YWx1ZSA6IHJpY2hWYWx1ZXMuZ2V0KHBhcnQudmFsdWUpIHx8IHBhcnQudmFsdWUpO1xuICAgICAgaWYgKHJpY2hWYWx1ZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICB9XG4gICAgfSwgKCkgPT4gU3RyaW5nKHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkYXRlVGltZSxcbiAgICBudW1iZXIsXG4gICAgcmVsYXRpdmVUaW1lLFxuICAgIGxpc3QsXG4gICAgZGF0ZVRpbWVSYW5nZVxuICB9O1xufVxuXG5leHBvcnRzLmNyZWF0ZUJhc2VUcmFuc2xhdG9yID0gY3JlYXRlQmFzZVRyYW5zbGF0b3I7XG5leHBvcnRzLmNyZWF0ZUZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcjtcbmV4cG9ydHMucmVzb2x2ZU5hbWVzcGFjZSA9IHJlc29sdmVOYW1lc3BhY2U7XG4iXSwibmFtZXMiOlsiSW50bE1lc3NhZ2VGb3JtYXQiLCJyZXF1aXJlIiwiUmVhY3QiLCJpbml0aWFsaXplQ29uZmlnIiwiX2ludGVyb3BEZWZhdWx0IiwiZSIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiSW50bE1lc3NhZ2VGb3JtYXRfX2RlZmF1bHQiLCJzZXRUaW1lWm9uZUluRm9ybWF0cyIsImZvcm1hdHMiLCJ0aW1lWm9uZSIsIk9iamVjdCIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJrZXkiLCJjb252ZXJ0Rm9ybWF0c1RvSW50bE1lc3NhZ2VGb3JtYXQiLCJmb3JtYXRzV2l0aFRpbWVab25lIiwiZGF0ZVRpbWUiLCJtZkRhdGVEZWZhdWx0cyIsImRhdGUiLCJkZWZhdWx0RGF0ZUZvcm1hdHMiLCJtZlRpbWVEZWZhdWx0cyIsInRpbWUiLCJkZWZhdWx0VGltZUZvcm1hdHMiLCJyZXNvbHZlUGF0aCIsImxvY2FsZSIsIm1lc3NhZ2VzIiwibmFtZXNwYWNlIiwiZnVsbEtleSIsImpvaW5QYXRoIiwiRXJyb3IiLCJjb25jYXQiLCJtZXNzYWdlIiwic3BsaXQiLCJmb3JFYWNoIiwicGFydCIsIm5leHQiLCJwcmVwYXJlVHJhbnNsYXRpb25WYWx1ZXMiLCJ2YWx1ZXMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJ0cmFuc2Zvcm1lZFZhbHVlcyIsImluZGV4IiwidmFsdWUiLCJ0cmFuc2Zvcm1lZCIsImNodW5rcyIsInJlc3VsdCIsImlzVmFsaWRFbGVtZW50IiwiY2xvbmVFbGVtZW50IiwiZ2V0TWVzc2FnZXNPckVycm9yIiwib25FcnJvciIsImFyZ3VtZW50cyIsImRlZmF1bHRPbkVycm9yIiwicmV0cmlldmVkTWVzc2FnZXMiLCJlcnJvciIsImludGxFcnJvciIsIkludGxFcnJvciIsIkludGxFcnJvckNvZGUiLCJNSVNTSU5HX01FU1NBR0UiLCJnZXRQbGFpbk1lc3NhZ2UiLCJjYW5kaWRhdGUiLCJ1bmVzY2FwZWRNZXNzYWdlIiwicmVwbGFjZSIsImhhc1BsYWNlaG9sZGVycyIsInRlc3QiLCJjcmVhdGVCYXNlVHJhbnNsYXRvciIsImNvbmZpZyIsIm1lc3NhZ2VzT3JFcnJvciIsImNyZWF0ZUJhc2VUcmFuc2xhdG9ySW1wbCIsIl9yZWYiLCJkZWZhdWx0VHJhbnNsYXRpb25WYWx1ZXMiLCJnbG9iYWxGb3JtYXRzIiwiZ2V0TWVzc2FnZUZhbGxiYWNrIiwiZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayIsIm1lc3NhZ2VGb3JtYXRDYWNoZSIsImdldEZhbGxiYWNrRnJvbUVycm9yQW5kTm90aWZ5IiwiY29kZSIsInRyYW5zbGF0ZUJhc2VGbiIsImNhY2hlS2V5IiwiU3RyaW5nIiwibWVzc2FnZUZvcm1hdCIsImhhcyIsImdldCIsImVycm9yTWVzc2FnZSIsIkFycmF5IiwiaXNBcnJheSIsIklOVkFMSURfTUVTU0FHRSIsIklOU1VGRklDSUVOVF9QQVRIIiwicGxhaW5NZXNzYWdlIiwiZm9ybWF0dGVycyIsImdldE51bWJlckZvcm1hdCIsImxvY2FsZXMiLCJvcHRpb25zIiwiSW50bCIsIk51bWJlckZvcm1hdCIsImdldERhdGVUaW1lRm9ybWF0IiwiRGF0ZVRpbWVGb3JtYXQiLCJnZXRQbHVyYWxSdWxlcyIsIlBsdXJhbFJ1bGVzIiwidGhyb3duRXJyb3IiLCJvcmlnaW5hbE1lc3NhZ2UiLCJzZXQiLCJmb3JtYXR0ZWRNZXNzYWdlIiwiZm9ybWF0IiwiRk9STUFUVElOR19FUlJPUiIsInRyYW5zbGF0ZUZuIiwicmljaCIsIm1hcmt1cCIsInJhdyIsInJlc29sdmVOYW1lc3BhY2UiLCJuYW1lc3BhY2VQcmVmaXgiLCJzbGljZSIsIlNFQ09ORCIsIk1JTlVURSIsIkhPVVIiLCJEQVkiLCJXRUVLIiwiTU9OVEgiLCJRVUFSVEVSIiwiWUVBUiIsIlVOSVRfU0VDT05EUyIsInNlY29uZCIsInNlY29uZHMiLCJtaW51dGUiLCJtaW51dGVzIiwiaG91ciIsImhvdXJzIiwiZGF5IiwiZGF5cyIsIndlZWsiLCJ3ZWVrcyIsIm1vbnRoIiwibW9udGhzIiwicXVhcnRlciIsInF1YXJ0ZXJzIiwieWVhciIsInllYXJzIiwicmVzb2x2ZVJlbGF0aXZlVGltZVVuaXQiLCJhYnNWYWx1ZSIsIk1hdGgiLCJhYnMiLCJjYWxjdWxhdGVSZWxhdGl2ZVRpbWVWYWx1ZSIsInVuaXQiLCJyb3VuZCIsImNyZWF0ZUZvcm1hdHRlciIsIm5vdyIsImdsb2JhbE5vdyIsImdsb2JhbFRpbWVab25lIiwiYXBwbHlUaW1lWm9uZSIsIl9vcHRpb25zIiwiRU5WSVJPTk1FTlRfRkFMTEJBQ0siLCJyZXNvbHZlRm9ybWF0T3JPcHRpb25zIiwidHlwZUZvcm1hdHMiLCJmb3JtYXRPck9wdGlvbnMiLCJmb3JtYXROYW1lIiwiTUlTU0lOR19GT1JNQVQiLCJnZXRGb3JtYXR0ZWRWYWx1ZSIsImZvcm1hdHRlciIsImdldEZhbGxiYWNrIiwiZGF0ZVRpbWVSYW5nZSIsInN0YXJ0IiwiZW5kIiwiZm9ybWF0UmFuZ2UiLCJqb2luIiwibnVtYmVyIiwiZ2V0R2xvYmFsTm93IiwiRGF0ZSIsImV4dHJhY3ROb3dEYXRlIiwibm93T3JPcHRpb25zIiwicmVsYXRpdmVUaW1lIiwiZGF0ZURhdGUiLCJub3dEYXRlIiwiZ2V0VGltZSIsIlJlbGF0aXZlVGltZUZvcm1hdCIsIm51bWVyaWMiLCJsaXN0Iiwic2VyaWFsaXplZFZhbHVlIiwicmljaFZhbHVlcyIsIk1hcCIsIml0ZW0iLCJzZXJpYWxpemVkSXRlbSIsInB1c2giLCJMaXN0Rm9ybWF0IiwiZm9ybWF0VG9QYXJ0cyIsIm1hcCIsInR5cGUiLCJzaXplIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/use-intl/dist/development/createFormatter-81d7e598.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/use-intl/dist/development/initializeConfig-c503e215.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nlet IntlErrorCode = /*#__PURE__*/ function(IntlErrorCode) {\n    IntlErrorCode[\"MISSING_MESSAGE\"] = \"MISSING_MESSAGE\";\n    IntlErrorCode[\"MISSING_FORMAT\"] = \"MISSING_FORMAT\";\n    IntlErrorCode[\"ENVIRONMENT_FALLBACK\"] = \"ENVIRONMENT_FALLBACK\";\n    IntlErrorCode[\"INSUFFICIENT_PATH\"] = \"INSUFFICIENT_PATH\";\n    IntlErrorCode[\"INVALID_MESSAGE\"] = \"INVALID_MESSAGE\";\n    IntlErrorCode[\"INVALID_KEY\"] = \"INVALID_KEY\";\n    IntlErrorCode[\"FORMATTING_ERROR\"] = \"FORMATTING_ERROR\";\n    return IntlErrorCode;\n}({});\nclass IntlError extends Error {\n    constructor(code, originalMessage){\n        let message = code;\n        if (originalMessage) {\n            message += \": \" + originalMessage;\n        }\n        super(message);\n        _defineProperty(this, \"code\", void 0);\n        _defineProperty(this, \"originalMessage\", void 0);\n        this.code = code;\n        if (originalMessage) {\n            this.originalMessage = originalMessage;\n        }\n    }\n}\nfunction joinPath() {\n    for(var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++){\n        parts[_key] = arguments[_key];\n    }\n    return parts.filter(Boolean).join(\".\");\n}\n/**\n * Contains defaults that are used for all entry points into the core.\n * See also `InitializedIntlConfiguration`.\n */ function defaultGetMessageFallback(props) {\n    return joinPath(props.namespace, props.key);\n}\nfunction defaultOnError(error) {\n    console.error(error);\n}\nfunction validateMessagesSegment(messages, invalidKeyLabels, parentPath) {\n    Object.entries(messages).forEach((_ref)=>{\n        let [key, messageOrMessages] = _ref;\n        if (key.includes(\".\")) {\n            let keyLabel = key;\n            if (parentPath) keyLabel += \" (at \".concat(parentPath, \")\");\n            invalidKeyLabels.push(keyLabel);\n        }\n        if (messageOrMessages != null && typeof messageOrMessages === \"object\") {\n            validateMessagesSegment(messageOrMessages, invalidKeyLabels, joinPath(parentPath, key));\n        }\n    });\n}\nfunction validateMessages(messages, onError) {\n    const invalidKeyLabels = [];\n    validateMessagesSegment(messages, invalidKeyLabels);\n    if (invalidKeyLabels.length > 0) {\n        onError(new IntlError(IntlErrorCode.INVALID_KEY, 'Namespace keys can not contain the character \".\" as this is used to express nesting. Please remove it or replace it with another character.\\n\\nInvalid '.concat(invalidKeyLabels.length === 1 ? \"key\" : \"keys\", \": \").concat(invalidKeyLabels.join(\", \"), '\\n\\nIf you\\'re migrating from a flat structure, you can convert your messages as follows:\\n\\nimport {set} from \"lodash\";\\n\\nconst input = {\\n  \"one.one\": \"1.1\",\\n  \"one.two\": \"1.2\",\\n  \"two.one.one\": \"2.1.1\"\\n};\\n\\nconst output = Object.entries(input).reduce(\\n  (acc, [key, value]) => set(acc, key, value),\\n  {}\\n);\\n\\n// Output:\\n//\\n// {\\n//   \"one\": {\\n//     \"one\": \"1.1\",\\n//     \"two\": \"1.2\"\\n//   },\\n//   \"two\": {\\n//     \"one\": {\\n//       \"one\": \"2.1.1\"\\n//     }\\n//   }\\n// }\\n')));\n    }\n}\n/**\n * Enhances the incoming props with defaults.\n */ function initializeConfig(_ref) {\n    let { getMessageFallback, messages, onError, ...rest } = _ref;\n    const finalOnError = onError || defaultOnError;\n    const finalGetMessageFallback = getMessageFallback || defaultGetMessageFallback;\n    {\n        if (messages) {\n            validateMessages(messages, finalOnError);\n        }\n    }\n    return {\n        ...rest,\n        messages,\n        onError: finalOnError,\n        getMessageFallback: finalGetMessageFallback\n    };\n}\nexports.IntlError = IntlError;\nexports.IntlErrorCode = IntlErrorCode;\nexports.defaultGetMessageFallback = defaultGetMessageFallback;\nexports.defaultOnError = defaultOnError;\nexports.initializeConfig = initializeConfig;\nexports.joinPath = joinPath;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXNlLWludGwvZGlzdC9kZXZlbG9wbWVudC9pbml0aWFsaXplQ29uZmlnLWM1MDNlMjE1LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsU0FBU0EsZ0JBQWdCQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsS0FBSztJQUN0Q0QsTUFBTUUsZUFBZUY7SUFDckIsSUFBSUEsT0FBT0QsS0FBSztRQUNkSSxPQUFPQyxjQUFjLENBQUNMLEtBQUtDLEtBQUs7WUFDOUJDLE9BQU9BO1lBQ1BJLFlBQVk7WUFDWkMsY0FBYztZQUNkQyxVQUFVO1FBQ1o7SUFDRixPQUFPO1FBQ0xSLEdBQUcsQ0FBQ0MsSUFBSSxHQUFHQztJQUNiO0lBQ0EsT0FBT0Y7QUFDVDtBQUNBLFNBQVNTLGFBQWFDLEtBQUssRUFBRUMsSUFBSTtJQUMvQixJQUFJLE9BQU9ELFVBQVUsWUFBWUEsVUFBVSxNQUFNLE9BQU9BO0lBQ3hELElBQUlFLE9BQU9GLEtBQUssQ0FBQ0csT0FBT0MsV0FBVyxDQUFDO0lBQ3BDLElBQUlGLFNBQVNHLFdBQVc7UUFDdEIsSUFBSUMsTUFBTUosS0FBS0ssSUFBSSxDQUFDUCxPQUFPQyxRQUFRO1FBQ25DLElBQUksT0FBT0ssUUFBUSxVQUFVLE9BQU9BO1FBQ3BDLE1BQU0sSUFBSUUsVUFBVTtJQUN0QjtJQUNBLE9BQU8sQ0FBQ1AsU0FBUyxXQUFXUSxTQUFTQyxNQUFLLEVBQUdWO0FBQy9DO0FBQ0EsU0FBU1AsZUFBZWtCLEdBQUc7SUFDekIsSUFBSXBCLE1BQU1RLGFBQWFZLEtBQUs7SUFDNUIsT0FBTyxPQUFPcEIsUUFBUSxXQUFXQSxNQUFNa0IsT0FBT2xCO0FBQ2hEO0FBRUEsSUFBSXFCLGdCQUFnQixXQUFXLEdBQUUsU0FBVUEsYUFBYTtJQUN0REEsYUFBYSxDQUFDLGtCQUFrQixHQUFHO0lBQ25DQSxhQUFhLENBQUMsaUJBQWlCLEdBQUc7SUFDbENBLGFBQWEsQ0FBQyx1QkFBdUIsR0FBRztJQUN4Q0EsYUFBYSxDQUFDLG9CQUFv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dXJjZXMiOlsid2VicGFjazovL2VuZ2xpc2gtY291cnNlcy8uL25vZGVfbW9kdWxlcy91c2UtaW50bC9kaXN0L2RldmVsb3BtZW50L2luaXRpYWxpemVDb25maWctYzUwM2UyMTUuanM/YWM0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xuICBpZiAodHlwZW9mIGlucHV0ICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmICh0eXBlb2YgcmVzICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xuICB2YXIga2V5ID0gX3RvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmxldCBJbnRsRXJyb3JDb2RlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChJbnRsRXJyb3JDb2RlKSB7XG4gIEludGxFcnJvckNvZGVbXCJNSVNTSU5HX01FU1NBR0VcIl0gPSBcIk1JU1NJTkdfTUVTU0FHRVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiTUlTU0lOR19GT1JNQVRcIl0gPSBcIk1JU1NJTkdfRk9STUFUXCI7XG4gIEludGxFcnJvckNvZGVbXCJFTlZJUk9OTUVOVF9GQUxMQkFDS1wiXSA9IFwiRU5WSVJPTk1FTlRfRkFMTEJBQ0tcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOU1VGRklDSUVOVF9QQVRIXCJdID0gXCJJTlNVRkZJQ0lFTlRfUEFUSFwiO1xuICBJbnRsRXJyb3JDb2RlW1wiSU5WQUxJRF9NRVNTQUdFXCJdID0gXCJJTlZBTElEX01FU1NBR0VcIjtcbiAgSW50bEVycm9yQ29kZVtcIklOVkFMSURfS0VZXCJdID0gXCJJTlZBTElEX0tFWVwiO1xuICBJbnRsRXJyb3JDb2RlW1wiRk9STUFUVElOR19FUlJPUlwiXSA9IFwiRk9STUFUVElOR19FUlJPUlwiO1xuICByZXR1cm4gSW50bEVycm9yQ29kZTtcbn0oe30pO1xuY2xhc3MgSW50bEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcihjb2RlLCBvcmlnaW5hbE1lc3NhZ2UpIHtcbiAgICBsZXQgbWVzc2FnZSA9IGNvZGU7XG4gICAgaWYgKG9yaWdpbmFsTWVzc2FnZSkge1xuICAgICAgbWVzc2FnZSArPSAnOiAnICsgb3JpZ2luYWxNZXNzYWdlO1xuICAgIH1cbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb2RlXCIsIHZvaWQgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwib3JpZ2luYWxNZXNzYWdlXCIsIHZvaWQgMCk7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICBpZiAob3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG9yaWdpbmFsTWVzc2FnZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gam9pblBhdGgoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJ0cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBwYXJ0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gcGFydHMuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy4nKTtcbn1cblxuLyoqXG4gKiBDb250YWlucyBkZWZhdWx0cyB0aGF0IGFyZSB1c2VkIGZvciBhbGwgZW50cnkgcG9pbnRzIGludG8gdGhlIGNvcmUuXG4gKiBTZWUgYWxzbyBgSW5pdGlhbGl6ZWRJbnRsQ29uZmlndXJhdGlvbmAuXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdEdldE1lc3NhZ2VGYWxsYmFjayhwcm9wcykge1xuICByZXR1cm4gam9pblBhdGgocHJvcHMubmFtZXNwYWNlLCBwcm9wcy5rZXkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdE9uRXJyb3IoZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcihlcnJvcik7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTWVzc2FnZXNTZWdtZW50KG1lc3NhZ2VzLCBpbnZhbGlkS2V5TGFiZWxzLCBwYXJlbnRQYXRoKSB7XG4gIE9iamVjdC5lbnRyaWVzKG1lc3NhZ2VzKS5mb3JFYWNoKF9yZWYgPT4ge1xuICAgIGxldCBba2V5LCBtZXNzYWdlT3JNZXNzYWdlc10gPSBfcmVmO1xuICAgIGlmIChrZXkuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgbGV0IGtleUxhYmVsID0ga2V5O1xuICAgICAgaWYgKHBhcmVudFBhdGgpIGtleUxhYmVsICs9IFwiIChhdCBcIi5jb25jYXQocGFyZW50UGF0aCwgXCIpXCIpO1xuICAgICAgaW52YWxpZEtleUxhYmVscy5wdXNoKGtleUxhYmVsKTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2VPck1lc3NhZ2VzICE9IG51bGwgJiYgdHlwZW9mIG1lc3NhZ2VPck1lc3NhZ2VzID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZU9yTWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMsIGpvaW5QYXRoKHBhcmVudFBhdGgsIGtleSkpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU1lc3NhZ2VzKG1lc3NhZ2VzLCBvbkVycm9yKSB7XG4gIGNvbnN0IGludmFsaWRLZXlMYWJlbHMgPSBbXTtcbiAgdmFsaWRhdGVNZXNzYWdlc1NlZ21lbnQobWVzc2FnZXMsIGludmFsaWRLZXlMYWJlbHMpO1xuICBpZiAoaW52YWxpZEtleUxhYmVscy5sZW5ndGggPiAwKSB7XG4gICAgb25FcnJvcihuZXcgSW50bEVycm9yKEludGxFcnJvckNvZGUuSU5WQUxJRF9LRVksIFwiTmFtZXNwYWNlIGtleXMgY2FuIG5vdCBjb250YWluIHRoZSBjaGFyYWN0ZXIgXFxcIi5cXFwiIGFzIHRoaXMgaXMgdXNlZCB0byBleHByZXNzIG5lc3RpbmcuIFBsZWFzZSByZW1vdmUgaXQgb3IgcmVwbGFjZSBpdCB3aXRoIGFub3RoZXIgY2hhcmFjdGVyLlxcblxcbkludmFsaWQgXCIuY29uY2F0KGludmFsaWRLZXlMYWJlbHMubGVuZ3RoID09PSAxID8gJ2tleScgOiAna2V5cycsIFwiOiBcIikuY29uY2F0KGludmFsaWRLZXlMYWJlbHMuam9pbignLCAnKSwgXCJcXG5cXG5JZiB5b3UncmUgbWlncmF0aW5nIGZyb20gYSBmbGF0IHN0cnVjdHVyZSwgeW91IGNhbiBjb252ZXJ0IHlvdXIgbWVzc2FnZXMgYXMgZm9sbG93czpcXG5cXG5pbXBvcnQge3NldH0gZnJvbSBcXFwibG9kYXNoXFxcIjtcXG5cXG5jb25zdCBpbnB1dCA9IHtcXG4gIFxcXCJvbmUub25lXFxcIjogXFxcIjEuMVxcXCIsXFxuICBcXFwib25lLnR3b1xcXCI6IFxcXCIxLjJcXFwiLFxcbiAgXFxcInR3by5vbmUub25lXFxcIjogXFxcIjIuMS4xXFxcIlxcbn07XFxuXFxuY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmVudHJpZXMoaW5wdXQpLnJlZHVjZShcXG4gIChhY2MsIFtrZXksIHZhbHVlXSkgPT4gc2V0KGFjYywga2V5LCB2YWx1ZSksXFxuICB7fVxcbik7XFxuXFxuLy8gT3V0cHV0Olxcbi8vXFxuLy8ge1xcbi8vICAgXFxcIm9uZVxcXCI6IHtcXG4vLyAgICAgXFxcIm9uZVxcXCI6IFxcXCIxLjFcXFwiLFxcbi8vICAgICBcXFwidHdvXFxcIjogXFxcIjEuMlxcXCJcXG4vLyAgIH0sXFxuLy8gICBcXFwidHdvXFxcIjoge1xcbi8vICAgICBcXFwib25lXFxcIjoge1xcbi8vICAgICAgIFxcXCJvbmVcXFwiOiBcXFwiMi4xLjFcXFwiXFxuLy8gICAgIH1cXG4vLyAgIH1cXG4vLyB9XFxuXCIpICkpO1xuICB9XG59XG5cbi8qKlxuICogRW5oYW5jZXMgdGhlIGluY29taW5nIHByb3BzIHdpdGggZGVmYXVsdHMuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVDb25maWcoX3JlZikge1xuICBsZXQge1xuICAgIGdldE1lc3NhZ2VGYWxsYmFjayxcbiAgICBtZXNzYWdlcyxcbiAgICBvbkVycm9yLFxuICAgIC4uLnJlc3RcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGZpbmFsT25FcnJvciA9IG9uRXJyb3IgfHwgZGVmYXVsdE9uRXJyb3I7XG4gIGNvbnN0IGZpbmFsR2V0TWVzc2FnZUZhbGxiYWNrID0gZ2V0TWVzc2FnZUZhbGxiYWNrIHx8IGRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2s7XG4gIHtcbiAgICBpZiAobWVzc2FnZXMpIHtcbiAgICAgIHZhbGlkYXRlTWVzc2FnZXMobWVzc2FnZXMsIGZpbmFsT25FcnJvcik7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgLi4ucmVzdCxcbiAgICBtZXNzYWdlcyxcbiAgICBvbkVycm9yOiBmaW5hbE9uRXJyb3IsXG4gICAgZ2V0TWVzc2FnZUZhbGxiYWNrOiBmaW5hbEdldE1lc3NhZ2VGYWxsYmFja1xuICB9O1xufVxuXG5leHBvcnRzLkludGxFcnJvciA9IEludGxFcnJvcjtcbmV4cG9ydHMuSW50bEVycm9yQ29kZSA9IEludGxFcnJvckNvZGU7XG5leHBvcnRzLmRlZmF1bHRHZXRNZXNzYWdlRmFsbGJhY2sgPSBkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrO1xuZXhwb3J0cy5kZWZhdWx0T25FcnJvciA9IGRlZmF1bHRPbkVycm9yO1xuZXhwb3J0cy5pbml0aWFsaXplQ29uZmlnID0gaW5pdGlhbGl6ZUNvbmZpZztcbmV4cG9ydHMuam9pblBhdGggPSBqb2luUGF0aDtcbiJdLCJuYW1lcyI6WyJfZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJrZXkiLCJ2YWx1ZSIsIl90b1Byb3BlcnR5S2V5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfdG9QcmltaXRpdmUiLCJpbnB1dCIsImhpbnQiLCJwcmltIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiU3RyaW5nIiwiTnVtYmVyIiwiYXJnIiwiSW50bEVycm9yQ29kZSIsIkludGxFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJjb2RlIiwib3JpZ2luYWxNZXNzYWdlIiwibWVzc2FnZSIsImpvaW5QYXRoIiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInBhcnRzIiwiQXJyYXkiLCJfa2V5IiwiZmlsdGVyIiwiQm9vbGVhbiIsImpvaW4iLCJkZWZhdWx0R2V0TWVzc2FnZUZhbGxiYWNrIiwicHJvcHMiLCJuYW1lc3BhY2UiLCJkZWZhdWx0T25FcnJvciIsImVycm9yIiwiY29uc29sZSIsInZhbGlkYXRlTWVzc2FnZXNTZWdtZW50IiwibWVzc2FnZXMiLCJpbnZhbGlkS2V5TGFiZWxzIiwicGFyZW50UGF0aCIsImVudHJpZXMiLCJmb3JFYWNoIiwiX3JlZiIsIm1lc3NhZ2VPck1lc3NhZ2VzIiwiaW5jbHVkZXMiLCJrZXlMYWJlbCIsImNvbmNhdCIsInB1c2giLCJ2YWxpZGF0ZU1lc3NhZ2VzIiwib25FcnJvciIsIklOVkFMSURfS0VZIiwiaW5pdGlhbGl6ZUNvbmZpZyIsImdldE1lc3NhZ2VGYWxsYmFjayIsInJlc3QiLCJmaW5hbE9uRXJyb3IiLCJmaW5hbEdldE1lc3NhZ2VGYWxsYmFjayIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/use-intl/dist/development/initializeConfig-c503e215.js\n");

/***/ })

};
;